<!DOCTYPE HTML>
<html>
<head>
  <meta name="google-site-verification" content="en_dejusB3O2_8PtG6GlYdYmaTEHr2fTEiIoZidOypY" />
  <meta name="baidu-site-verification" content="7tszoAHV0d" />
  <meta charset="utf-8">
  
  <title>Page 3 | 百变千幻衡山云雾十三式</title>
  <meta name="author" content="玉娇龙">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="百变千幻衡山云雾十三式"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="百变千幻衡山云雾十三式" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-62877030-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?null";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">百变千幻衡山云雾十三式</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Rss feed">
			  <i class="fa fa-rss-square"></i>Rss
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Wikirize my knowledge</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Yet another bootstrap theme.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-02-16 </div>
			<div class="article-title"><a href="/2015/02/16/OA/POJ_summary/" title="A collection of Hello World applications from helloworld.org.">poj题目分类</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="poj题目分类_小媛在努力原创">poj题目分类 小媛在努力原创</h1><p>标签（空格分隔）： oa</p>
<hr>
<p>[TOC]</p>
<h1 id="初期:">初期:</h1><h2 id="一-基本算法:">一.基本算法:</h2><h3 id="(1)枚举-_(poj1753,poj2965)">(1)枚举. (poj1753,poj2965)</h3><h3 id="(2)贪心(poj1328,poj2109,poj2586)">(2)贪心(poj1328,poj2109,poj2586)</h3><h3 id="(3)递归和分治法-">(3)递归和分治法.</h3><h3 id="(4)递推-">(4)递推.</h3><h3 id="(5)构造法-(poj3295)">(5)构造法.(poj3295)</h3><h3 id="(6)模拟法-(poj1068,poj2632,poj1573,poj2993,poj2996)">(6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)</h3><h2 id="二-图算法:">二.图算法:</h2><h3 id="(1)图的深度优先遍历和广度优先遍历-">(1)图的深度优先遍历和广度优先遍历.</h3><h3 id="(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)">(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)</h3><p> (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)</p>
<h3 id="(3)最小生成树算法(prim,kruskal)">(3)最小生成树算法(prim,kruskal)</h3><p> (poj1789,poj2485,poj1258,poj3026)</p>
<h3 id="(4)拓扑排序_(poj1094)">(4)拓扑排序 (poj1094)</h3><h3 id="(5)二分图的最大匹配_(匈牙利算法)_(poj3041,poj3020)">(5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)</h3><h3 id="(6)最大流的增广路算法(KM算法)-_(poj1459,poj3436)">(6)最大流的增广路算法(KM算法). (poj1459,poj3436)</h3><h2 id="三-数据结构-">三.数据结构.</h2><h3 id="(1)串_(poj1035,poj3080,poj1936)">(1)串 (poj1035,poj3080,poj1936)</h3><h3 id="(2)排序(快排、归并排(与逆序数有关)、堆排)_(poj2388,poj2299)">(2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)</h3><h3 id="(3)简单并查集的应用-">(3)简单并查集的应用.</h3><h3 id="(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)">(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)</h3><p> (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)</p>
<h3 id="(5)哈夫曼树(poj3253)">(5)哈夫曼树(poj3253)</h3><h3 id="(6)堆">(6)堆</h3><h3 id="(7)trie树(静态建树、动态建树)_(poj2513)">(7)trie树(静态建树、动态建树) (poj2513)</h3><h2 id="四-简单搜索">四.简单搜索</h2><h3 id="(1)深度优先搜索_(poj2488,poj3083,poj3009,poj1321,poj2251)">(1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)</h3><h3 id="(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087-poj3414)">(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)</h3><h3 id="(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)">(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)</h3><h2 id="五-动态规划">五.动态规划</h2><h3 id="(1)背包问题-_(poj1837,poj1276)">(1)背包问题. (poj1837,poj1276)</h3><h3 id="(2)型如下表的简单DP(可参考lrj的书_page149):">(2)型如下表的简单DP(可参考lrj的书 page149):</h3><p><em>1. E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)
 </em>2. E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)<br> (poj3176,poj1080,poj1159)<br>  *3. C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)</p>
<h2 id="六-数学">六.数学</h2><h3 id="(1)组合数学:">(1)组合数学:</h3><h4 id="1-加法原理和乘法原理-">1.加法原理和乘法原理.</h4><h4 id="2-排列组合-">2.排列组合.</h4><h4 id="3-递推关系-">3.递推关系.</h4><pre><code><span class="list">(<span class="keyword">POJ3252</span>,poj1850,poj1019,poj1942)</span>
</code></pre><h3 id="(2)数论-">(2)数论.</h3><h4 id="1-素数与整除问题">1.素数与整除问题</h4><h4 id="2-进制位-">2.进制位.</h4><h4 id="3-同余模运算-">3.同余模运算.</h4><pre><code><span class="list">(<span class="keyword">poj2635</span>, poj3292,poj1845,poj2115)</span>
</code></pre><h3 id="(3)计算方法-">(3)计算方法.</h3><pre><code><span class="number">1.</span>二分法求解单调函数相关知识.<span class="comment">(poj3273,poj3258,poj1905,poj3122)</span>
</code></pre><h2 id="七-计算几何学-">七.计算几何学.</h2><h3 id="(1)几何公式-">(1)几何公式.</h3><h3 id="(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等)-_(poj2031,poj1039)">(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)</h3><h3 id="(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)">(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)</h3><pre><code><span class="list">(<span class="keyword">poj1408</span>,poj1584)</span>
</code></pre><h3 id="(4)凸包-_(poj2187,poj1113)">(4)凸包. (poj2187,poj1113)</h3><h1 id="中级:">中级:</h1><h2 id="一-基本算法:-1">一.基本算法:</h2><h3 id="(1)C++的标准模版库的应用-_(poj3096,poj3007)">(1)C++的标准模版库的应用. (poj3096,poj3007)</h3><h3 id="(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)">(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)</h3><h2 id="二-图算法:-1">二.图算法:</h2><h3 id="(1)差分约束系统的建立和求解-_(poj1201,poj2983)">(1)差分约束系统的建立和求解. (poj1201,poj2983)</h3><h3 id="(2)最小费用最大流(poj2516,poj2516,poj2195)">(2)最小费用最大流(poj2516,poj2516,poj2195)</h3><h3 id="(3)双连通分量(poj2942)">(3)双连通分量(poj2942)</h3><h3 id="(4)强连通分支及其缩点-(poj2186)">(4)强连通分支及其缩点.(poj2186)</h3><h3 id="(5)图的割边和割点(poj3352)">(5)图的割边和割点(poj3352)</h3><h3 id="(6)最小割模型、网络流规约(poj3308,_)">(6)最小割模型、网络流规约(poj3308, )</h3><h2 id="三-数据结构--1">三.数据结构.</h2><h3 id="(1)线段树-_(poj2528,poj2828,poj2777,poj2886,poj2750)">(1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)</h3><h3 id="(2)静态二叉检索树-_(poj2482,poj2352)">(2)静态二叉检索树. (poj2482,poj2352)</h3><h3 id="(3)树状树组(poj1195,poj3321)">(3)树状树组(poj1195,poj3321)</h3><h3 id="(4)RMQ-_(poj3264,poj3368)">(4)RMQ. (poj3264,poj3368)</h3><h3 id="(5)并查集的高级应用-_(poj1703,2492)">(5)并查集的高级应用. (poj1703,2492)</h3><h3 id="(6)KMP算法-_(poj1961,poj2406)">(6)KMP算法. (poj1961,poj2406)</h3><h2 id="四-搜索">四.搜索</h2><h3 id="(1)最优化剪枝和可行性剪枝">(1)最优化剪枝和可行性剪枝</h3><h3 id="(2)搜索的技巧和优化_(poj3411,poj1724)">(2)搜索的技巧和优化 (poj3411,poj1724)</h3><h3 id="(3)记忆化搜索(poj3373,poj1691)">(3)记忆化搜索(poj3373,poj1691)</h3><h2 id="五-动态规划-1">五.动态规划</h2><h3 id="(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)">(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)</h3><pre><code><span class="list">(<span class="keyword">poj1191</span>,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)</span>
</code></pre><h3 id="(2)记录状态的动态规划-_(POJ3254,poj2411,poj1185)">(2)记录状态的动态规划. (POJ3254,poj2411,poj1185)</h3><h3 id="(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)">(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)</h3><h2 id="六-数学-1">六.数学</h2><h3 id="(1)组合数学:-1">(1)组合数学:</h3><h4 id="1-容斥原理-">1.容斥原理.</h4><h4 id="2-抽屉原理-">2.抽屉原理.</h4><h4 id="3-置换群与Polya定理(poj1286,poj2409,poj3270,poj1026)-">3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).</h4><h4 id="4-递推关系和母函数-">4.递推关系和母函数.</h4><h3 id="(2)数学-">(2)数学.</h3><h4 id="1-高斯消元法(poj2947,poj1487,_poj2065,poj1166,poj1222)">1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)</h4><h4 id="2-概率问题-_(poj3071,poj3440)">2.概率问题. (poj3071,poj3440)</h4><h4 id="3-GCD、扩展的欧几里德(中国剩余定理)_(poj3101)">3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)</h4><h3 id="(3)计算方法--1">(3)计算方法.</h3><h4 id="1-0/1分数规划-_(poj2976)">1.0/1分数规划. (poj2976)</h4><h4 id="2-三分法求解单峰(单谷)的极值-">2.三分法求解单峰(单谷)的极值.</h4><h4 id="3-矩阵法(poj3150,poj3422,poj3070)">3.矩阵法(poj3150,poj3422,poj3070)</h4><h4 id="4-迭代逼近(poj3301)">4.迭代逼近(poj3301)</h4><h3 id="(4)随机化算法(poj3318,poj2454)">(4)随机化算法(poj3318,poj2454)</h3><h3 id="(5)杂题-">(5)杂题.</h3><pre><code><span class="list">(<span class="keyword">poj1870</span>,poj3296,poj3286,poj1095)</span>
</code></pre><h2 id="七-计算几何学--1">七.计算几何学.</h2><h3 id="(1)坐标离散化-">(1)坐标离散化.</h3><h3 id="(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用)-">(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).</h3><pre><code><span class="list">(<span class="keyword">poj1765</span>,poj1177,poj1151,poj3277,poj2280,poj3004)</span>
</code></pre><h3 id="(3)多边形的内核(半平面交)(poj3130,poj3335)">(3)多边形的内核(半平面交)(poj3130,poj3335)</h3><h3 id="(4)几何工具的综合应用-(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)">(4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)</h3><h1 id="高级:">高级:</h1><h2 id="一-基本算法要求:">一.基本算法要求:</h2><h3 id="(1)代码快速写成,精简但不失风格">(1)代码快速写成,精简但不失风格</h3><p>   (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)</p>
<h3 id="(2)保证正确性和高效性-_poj3434">(2)保证正确性和高效性. poj3434</h3><h2 id="二-图算法:-2">二.图算法:</h2><h3 id="(1)度限制最小生成树和第K最短路-_(poj1639)">(1)度限制最小生成树和第K最短路. (poj1639)</h3><h3 id="(2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)">(2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)</h3><p>  (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446</p>
<h3 id="(3)最优比率生成树-_(poj2728)">(3)最优比率生成树. (poj2728)</h3><h3 id="(4)最小树形图(poj3164)">(4)最小树形图(poj3164)</h3><h3 id="(5)次小生成树-">(5)次小生成树.</h3><h3 id="(6)无向图、有向图的最小环">(6)无向图、有向图的最小环</h3><h2 id="三-数据结构--2">三.数据结构.</h2><h3 id="(1)trie图的建立和应用-_(poj2778)">(1)trie图的建立和应用. (poj2778)</h3><h3 id="(2)LCA和RMQ问题(LCA(最近公共祖先问题)_有离线算法(并查集+dfs)_和_在线算法">(2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法</h3><p>(RMQ+dfs)).(poj1330)</p>
<h3 id="(3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的">(3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的</h3><pre><code>目的). <span class="comment">(poj2823)</span>
</code></pre><h3 id="(4)左偏树(可合并堆)-">(4)左偏树(可合并堆).</h3><h3 id="(5)后缀树(非常有用的数据结构,也是赛区考题的热点)-">(5)后缀树(非常有用的数据结构,也是赛区考题的热点).</h3><pre><code><span class="list">(<span class="keyword">poj3415</span>,poj3294)</span>
</code></pre><h2 id="四-搜索-1">四.搜索</h2><h3 id="(1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)">(1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)</h3><h3 id="(2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法-_(poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)">(2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)</h3><h3 id="(3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法-_(poj3131,poj2870,poj2286)">(3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)</h3><h2 id="五-动态规划-2">五.动态规划</h2><h3 id="(1)需要用数据结构优化的动态规划-">(1)需要用数据结构优化的动态规划.</h3><pre><code><span class="list">(<span class="keyword">poj2754</span>,poj3378,poj3017)</span>
</code></pre><h3 id="(2)四边形不等式理论-">(2)四边形不等式理论.</h3><h3 id="(3)较难的状态DP(poj3133)">(3)较难的状态DP(poj3133)</h3><h2 id="六-数学-2">六.数学</h2><h3 id="(1)组合数学-">(1)组合数学.</h3><pre><code><span class="number">1</span>.<span class="variable">MoBius</span>反演(poj2888,poj2154)
<span class="number">2</span>.偏序关系理论.
</code></pre><h3 id="(2)博奕论-">(2)博奕论.</h3><pre><code><span class="number">1</span>.极大极小过程(poj3317,poj1085)
<span class="number">2</span>.<span class="variable">Nim</span>问题.
</code></pre><h2 id="七-计算几何学--2">七.计算几何学.</h2><h3 id="(1)半平面求交(poj3384,poj2540)">(1)半平面求交(poj3384,poj2540)</h3><h3 id="(2)可视图的建立(poj2966)">(2)可视图的建立(poj2966)</h3><h3 id="(3)点集最小圆覆盖-">(3)点集最小圆覆盖.</h3><h3 id="(4)对踵点(poj2079)">(4)对踵点(poj2079)</h3><pre><code>八.综合题.
(poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)
</code></pre>
	
	</div>
  <a type="button" href="/2015/02/16/OA/POJ_summary/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-02-16 </div>
			<div class="article-title"><a href="/2015/02/16/Leetcode/LeetcodeRecursion/" title="Leetcode总结题型.">leetcode中学习recursion</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<ul>
<li>N00t大神的recursion出神入化</li>
<li>LC中大量的recursion解法</li>
<li>recursion的关键在于代码结构, 以及param/return.</li>
</ul>
</blockquote>
<h2 id="recursion的种类">recursion的种类</h2><h3 id="1-_简单的按照结构分的有">1. 简单的按照结构分的有</h3><h4 id="1个rec-_以及简单三明治关系-">1个rec. 以及简单三明治关系.</h4><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">rec</span><span class="literal">()</span>&#123;</span><br><span class="line">    codeTD;</span><br><span class="line">    <span class="keyword">rec</span><span class="literal">()</span>;</span><br><span class="line">    codeBU;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里面的codeTD可以看作是walk DOWN the tree, codeBU理解为walk UP the tree.</li>
</ul>
<h4 id="1个rec-_但是在for_loop里面的话,_会更有意思-">1个rec. 但是在for loop里面的话, 会更有意思.</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rec<span class="comment">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(lastRow)</span></span><br><span class="line">        res.add<span class="comment">(path + s)</span>;</span><br><span class="line">    for<span class="comment">(i = 1; i &lt; path.size()</span>; i++)&#123;</span><br><span class="line">        rec<span class="comment">(path.append, res)</span>;</span><br><span class="line">        path.delete;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这在restore IP的N00t的第一个解法中遇到.</li>
</ul>
<h4 id="1个recursion,_这次是在for_each()_括号里面-_更有意思啦">1个recursion, 这次是在for each() 括号里面. 更有意思啦</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>&lt;<span class="type">List</span>&lt;?&gt; segmentRec(<span class="type">String</span> s) &#123;</span><br><span class="line">    // <span class="keyword">do</span> something</span><br><span class="line">    <span class="keyword">for</span> ( i ) &#123;</span><br><span class="line">        rest = s.substring(i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">List</span>&lt;?&gt; seg : segmentRec(rest)) &#123;</span><br><span class="line">            // <span class="keyword">do</span> something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个是在word segment里面用到.</li>
</ul>
<h4 id="2个连续rec_call-_有param,_有return">2个连续rec call. 有param, 有return</h4><h5 id="在triangle_Path_Sum中的N00t的第一个解法-">在triangle Path Sum中的N00t的第一个解法.</h5><ul>
<li>注意这里的minSum既是recursion method的param, 又是param的返回值. 这在recursion中很常用. 可以记录在<strong>触底反弹</strong>的时候不断update这个值. </li>
<li>因为rec有返回值, 而且复制给同一个var(minSum). 因为2个recursion的话, 第二个rec中的param会在第一个rec算完后update. 所以这一套组合拳就能在Traversal tree中不断update. 也就相当于brute force的找所有组合的极值. </li>
</ul>
<ul>
<li>这就体现出recursion的意义: 有目的, 有结构的遍历符合规则的结构的所有path. 例如triangle Path Sum就是想要找DFS path的最小路径. 而不是随便一个乱序的路径. <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> DFS(a, <span class="keyword">sum</span>, minSum) &#123;</span><br><span class="line">  <span class="keyword">sum</span> += a;  <span class="comment">// walking down the tree.</span></span><br><span class="line">  <span class="keyword">if</span> (lastRow &amp;&amp; <span class="keyword">sum</span> &lt; minSum)  <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    minSum = DFS(a, <span class="keyword">sum</span>, minSum);  <span class="comment">// 注意这里的赋值是minSum, 而不是其他var name. 所以跟着的第二条recursion中的minSum才会update.</span></span><br><span class="line">    minSum = DFS(a, <span class="keyword">sum</span>, minSum);  <span class="comment">// 这里的minSum用于DFS的return.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minSum; <span class="comment">// walking up the tree.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="还有个很好的例子就是flatten_Binary_Tree的九章算法模版-">还有个很好的例子就是flatten Binary Tree的九章算法模版.</h5><ul>
<li>recursion中有param不一定必须return. 主要修改就OK了. </li>
<li>关键在于2个recursion的时候, 第二个recursion计算的root</li>
</ul>
<h5 id="还有很经典的是Maximum_Subarray的divid_and_conquer解法-">还有很经典的是Maximum Subarray的divid and conquer解法.</h5><ul>
<li>2个连续的rec. 一个左子树, 一个右子树. 然后下面的code是向上走. 即合并的时候做的. 干什么呢? 自然是用来合并左右子树计算得到的结果. <a href="http://joycelearning.blogspot.com/2013/10/leetcode-maximum-subarray.html" target="_blank" rel="external">一天一学的Java</a>分析很到位.</li>
</ul>
<h4 id="2个不连续的rec_call-_中间有code-_注意N00t和programCreek的一点区别">2个不连续的rec call. 中间有code. 注意N00t和programCreek的一点区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">rec</span><span class="params">(l, h)</span> </span>&#123;</span><br><span class="line">  mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">  leftNode = rec(lo, mid-<span class="number">1</span>);</span><br><span class="line">  middleCode;</span><br><span class="line">  rightNode = rec(mid+<span class="number">1</span>, hi);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这在Sorted list to Binary Tree里面用到了.<h4 id="2个不连续的recur_call-_中间有code,_而且使用的return-">2个不连续的recur call. 中间有code, 而且使用的return.</h4></li>
<li>经典案例: Recover Binary Search Tree —- N00t的方法. 这才是真正的使用in-order. 注意每一次的rec call里面的param都变化. 而不是像dummy in-order那样对称.<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode inorder(TreeNode root, TreeNode[] nodes, TreeNode pre) &#123;  </span><br><span class="line">   <span class="keyword">if</span> (root == <span class="constant">null</span>) <span class="constant">return</span> pre;  </span><br><span class="line">  <span class="comment"> // left subtree  </span></span><br><span class="line">   TreeNode <span class="keyword">last</span> = inorder(root.left, nodes, pre);  </span><br><span class="line">  <span class="comment"> // visit  </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">last</span> != <span class="constant">null</span> &amp;&amp; root.val &lt; <span class="keyword">last</span>.val) &#123;  </span><br><span class="line">    <span class="comment"> // some code</span></span><br><span class="line">   &#125;  </span><br><span class="line">  <span class="comment"> // right subtree  </span></span><br><span class="line">   <span class="constant">return</span> inorder(root.<span class="constant">right</span>, nodes, root);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3个rec_call,_中间有code,_有param,_有返回-">3个rec call, 中间有code, 有param, 有返回.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DFS(tri, row, col, HashMap)&#123;</span><br><span class="line">    <span class="comment">// base condition</span></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span>(Map.contains())</span><br><span class="line">        min+= Math.min(DFS(Hashmap), DFS(Hashmap));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        min+= Math.min(map.get(), DFS(HashMap));</span><br><span class="line">    map.put(row, min);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在Triangle Path Sum的DFS recursion解法里面用到. 注意这里的Math.min()里面的第二个DFS的map已经在在第一个DFS中改变了.</li>
<li>记住: java永远是call by value. <ul>
<li>所以primitive 的话不会改变. 于是必须return. 所以在Triangle Path Sum中的第一个解法必须return, 然后第二个recursion的minSum才是改动过的.</li>
<li>如果是object, call-by-value的是地址. 所以可以改动. 于是不需要return. 就如Triangle Path Sum里面的DFS解法的map. 这里的map是重复使用(update)的.</li>
<li>其实这里就是段公子说的用HashMap来代替array保存DP结果更有通用性. array其实是最简单的HashMap, 即key是index, value则是a[i].</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-_按照DFS中使用的分">2. 按照DFS中使用的分</h3><blockquote>
<ul>
<li>根据<a href="http://leetcodesummary.blogspot.com/2013/10/leetcode-treerecursion.html" target="_blank" rel="external">leetcode summary的博客</a></li>
<li>还有就是CS的关键: <strong>抽象抽象再抽象</strong>. 并不一定要真的是一个Tree放在那里让你traverse. 而是题目可以按照tree的结构分析分解和理解. 比如说word segment, word ladder, Graph, 乃至2-SAT-&gt;SCC. 等等.</li>
</ul>
</blockquote>
<h4 id="例如NP问题:_Subsets_I/II">例如NP问题: Subsets I/II</h4><h4 id="NP问题:_Permutation_I/II">NP问题: Permutation I/II</h4>
	
	</div>
  <a type="button" href="/2015/02/16/Leetcode/LeetcodeRecursion/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-02-16 </div>
			<div class="article-title"><a href="/2015/02/16/OA/ACM/" title="A collection of Hello World applications from helloworld.org.">ACM题集以及各种总结大全(转载)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>虽然退役了，但是整理一下，供小弟小妹们以后切题方便一些，但由于近来考试太多，顾退役总结延迟一段时间再写！先写一下各种分类和题集，欢迎各位大牛路过指正。</p>
<ul>
<li>转载于<a href="http://blog.csdn.net/liuqiyao_01/article/details/9079611" target="_blank" rel="external">671coder的专栏</a></li>
</ul>
</blockquote>
<h2 id="ACM入门">ACM入门</h2><ul>
<li><a href="http://acm.hdu.edu.cn/" target="_blank" rel="external">杭州电子科技大学(hdu)ACM题目</a></li>
<li><a href="http://acm.hdu.edu.cn/" target="_blank" rel="external">关于acm的帮助</a></li>
<li><a href="http://poj.org/" target="_blank" rel="external">北京大学(poj)题目</a></li>
<li><a href="http://acm.zju.edu.cn/" target="_blank" rel="external">浙江大学(zoj)题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php" target="_blank" rel="external">uva题目</a></li>
<li><a href="http://download.csdn.net/detail/liuqiyao_01/5568001" target="_blank" rel="external">青理工大学acm宣传ppt(据说就是耀哥的魅力害了好多人来搞ACM)</a></li>
</ul>
<h2 id="水题">水题</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477645" target="_blank" rel="external">hdu水题分类之耀哥版</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477801" target="_blank" rel="external">poj题目分类  小媛在努力原创</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=95" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第五章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=102" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第六章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=106" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第七章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=113" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第八章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=113" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第九章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=115" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第十章题目</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=116" target="_blank" rel="external">算法竞赛入门经典》刘汝佳白皮书 第十一章题目</a></li>
</ul>
<h2 id="搜索">搜索</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478714" target="_blank" rel="external">图的搜索分类 夏天的风原创</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478719" target="_blank" rel="external">范围搜索简介</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8786998" target="_blank" rel="external">高级搜索题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797318" target="_blank" rel="external">极大极小搜索题集</a></li>
</ul>
<h2 id="图论">图论</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477827" target="_blank" rel="external">poj图论综合题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797356" target="_blank" rel="external">并查集&amp;最小生成树题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797353" target="_blank" rel="external">最短路&amp;差分约束题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8479339" target="_blank" rel="external">欧拉回路&amp;特殊图下的哈密顿回路题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/26964205" target="_blank" rel="external">欧拉路&amp;欧拉回路</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478726" target="_blank" rel="external">拓扑排序题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797349" target="_blank" rel="external">二分匹配题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478730" target="_blank" rel="external">连通&amp;LCA题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478729" target="_blank" rel="external">网络流题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797336" target="_blank" rel="external">2-SAT题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797346" target="_blank" rel="external">KM匹配题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478711" target="_blank" rel="external">Dancing Links 题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/26963579" target="_blank" rel="external">一般图的匹配题集</a></li>
</ul>
<h2 id="数据结构">数据结构</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/9712191" target="_blank" rel="external">线段树题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8798241" target="_blank" rel="external">AC自动机题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/26963913" target="_blank" rel="external">树状数组题集</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/26964103" target="_blank" rel="external">树状数组小结</a></li>
</ul>
<h2 id="动态规划">动态规划</h2><ul>
<li>经典讲解：<ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8521776" target="_blank" rel="external">背包九讲</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8752034" target="_blank" rel="external">状态压缩DP 属性DP</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8765812" target="_blank" rel="external">100个动规方程</a></li>
</ul>
</li>
<li>题集：<ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477725" target="_blank" rel="external">背包DP专辑</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477730" target="_blank" rel="external">树形DP专辑</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8477740" target="_blank" rel="external">概率DP专辑</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8797438" target="_blank" rel="external">区间DP专辑</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/9109419" target="_blank" rel="external">数位DP专辑</a></li>
</ul>
</li>
</ul>
<h2 id="数论">数论</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8478723" target="_blank" rel="external">博弈题集</a></li>
</ul>
<h2 id="计算几何">计算几何</h2><ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/8750742" target="_blank" rel="external">poj计算几何入门推荐</a></li>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/26964261" target="_blank" rel="external">另一个题集</a><h2 id="模拟">模拟</h2></li>
</ul>
<h2 id="各种大牛退役帖合集">各种大牛退役帖合集</h2><h2 id="各种YY合集">各种YY合集</h2>
	
	</div>
  <a type="button" href="/2015/02/16/OA/ACM/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-16 </div>
			<div class="article-title"><a href="/2015/01/16/Leetcode/highFreq/Freq1/" title="A collection of Hello World applications from helloworld.org.">Leetcode freq 1</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="20150122">20150122</h2><h3 id="Length_of_Last_Word">Length of Last Word</h3><ul>
<li>额, 简单题…</li>
</ul>
<h3 id="Same_Tree">Same Tree</h3><h3 id="Maximum_Depth_of_Binary_Tree">Maximum Depth of Binary Tree</h3><ul>
<li>DFS或者BFS都能解决. 其中BFS的N00t的写法是queue+Null nod作为该level的结束, 并且只有while没有内层的for loop</li>
</ul>
<h3 id="Minimum_Depth_of_Binary_Tree">Minimum Depth of Binary Tree</h3><ul>
<li>还是DFS跟BFS都能解决. 但是BFS在这里效率更高, 因为只要找到第一个leaf就返回.</li>
</ul>
<h3 id="Word_Ladder_II">Word Ladder II</h3><h3 id="Longest_Common_Prefix">Longest Common Prefix</h3><h3 id="Pascal’s_Triangle">Pascal’s Triangle</h3><h3 id="Pascal’s_Triangle_II">Pascal’s Triangle II</h3><h2 id="20150120">20150120</h2><h3 id="Best_Time_to_Buy_and_Sell_Stock_II">Best Time to Buy and Sell Stock II</h3><ul>
<li>参考<a href="http://blog.csdn.net/fightforyourdream/article/details/14503469" target="_blank" rel="external">CSDN的FightForDream分析DP</a></li>
</ul>
<h3 id="Best_Time_to_Buy_and_Sell_Stock_III">Best Time to Buy and Sell Stock III</h3><h3 id="ZigZag_Conversion">ZigZag Conversion</h3><h3 id="3Sum_Closest">3Sum Closest</h3><h3 id="Longest_Valid_Parentheses">Longest Valid Parentheses</h3><h3 id="Permutation_Sequence">Permutation Sequence</h3><ul>
<li>数学找规律题目. N00t的例子加上Ganker的解释. 很容易理解. 关键是code要写的快.</li>
</ul>
<h2 id="20150115">20150115</h2><h3 id="Substring_with_Concatenation_of_All_Words">Substring with Concatenation of All Words</h3><ul>
<li>这道题目和Longest non-repeated subsequence都是用Ganker大大的双pointer窗口大法.</li>
<li>看了N00t的才知道原来Ganker这种双指针法<del>原来就是简化的KMP string match算法</del>. 并不是. KMP的关键在于preprocess了一个DFA, 所以能够实现O(n).</li>
</ul>
<h3 id="Simplify_Path">Simplify Path</h3><ul>
<li><p>先读懂Unix中的path的op意义. 发现<a href="http://huntfor.iteye.com/blog/2066875" target="_blank" rel="external">阿猫阿狗blog</a>的解释最清晰易懂. 我也测试了一下: 确实就是很简单的规则: <code>/.表示当前目录，/..表示上级目录，/表示根目录</code>. 如下图所示:<br><img src="http://7xj2zx.com1.z0.glb.clouddn.com/freq1_simpPath1.PNG" alt="freq1SimPath">. <code>cd /MOOC/./../MOOC</code>. 以<code>/</code>为分界来认识就是: cd /(回到根目录); MOOC(去根目录下的MOOC文件夹); /..(返回上一级, 即回到c:); /.(表示当前目录, 所以还是在c:); /MOOC. 又去到MOOC文件夹. 所以执行完后表示还是去到了MOOC文件夹中. 而在command里的第二行则直接cd MOOC是找不到的, 因为pwd是c:\MOOC\NodeJS_Intro. 题目已经说了给的是<strong>absolute path</strong>, 即从根目录开始的path. 所以打头是<code>/</code>.</p>
</li>
<li><p>这里再复习一下Stack/Queue:</p>
<ol>
<li>虽然Stack在Java.util已经实现了stack class, 但最好不要用, 因为很多问题. 参考<a href="http://cs.lmu.edu/~ray/notes/stacks/" target="_blank" rel="external">lmu课件</a>. 所以Ganker也是使用的LinkedList来instantiate, 而且要注意, 这时候是: <code>LinkedList&lt;Integer&gt; stack = LinkedList&lt;Integer&gt;()</code>, 只是这个list叫做stack而已. 其实看了<a href="http://stackoverflow.com/a/12524949" target="_blank" rel="external">SOF stack/deque</a>, 讲了Stack在JavaDoc里面也是推荐用Deque来当作stack用: <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></li>
<li>Queue更彻底, 是interface. 根本不能instantiate. 所以也可以使用LinkedList来实现: <code>Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;()</code>.</li>
</ol>
</li>
<li><p>细节在于Java里面的split(regex, limit)是split pattern之前和之后的. 所以splits[0]是””. 一个空的string. 参见<a href="http://stackoverflow.com/questions/9389503/how-to-prevent-java-lang-string-split-from-creating-a-leading-empty-string" target="_blank" rel="external">SOF: java split leading empty string</a>. 即: split之后会出现的值是: “”, “a”, “.”, “..”. 所以当stack不空且”..”的时候pop(). 当split的值是有效的char, 换句话说: 不是无效的char: “”, “.”, “..”的时候就push().</p>
</li>
</ul>
<h3 id="Unique_Binary_Search_Trees_I">Unique Binary Search Trees I</h3><ul>
<li>这是一个很有意思的题, 因为在于解题思路可以有2个方向<ol>
<li>想明白之后可以直接是公式解法. 这个是数学的解法. 而且这个数学解法的Sigma的处理也学到了:就是loop里面<code>res+= func(i)</code>.</li>
<li>利用<a href="http://fisherlei.blogspot.com/2013/03/leetcode-unique-binary-search-trees.html" target="_blank" rel="external">水中的鱼所说的BST的性质</a>: <code>lchild&lt;root&lt;rchild</code>. 所以如下图所示: <img src="http://7xj2zx.com1.z0.glb.clouddn.com/Freq1_uniBST1.JPG" alt="freq1_uniBST">. 这里参考的<a href="http://jane4532.blogspot.com/2013/07/unique-binary-search-tree.html" target="_blank" rel="external">SophieJ递归解法</a>. 这里的rec(i)让我思考了半天, 他的含义并不是: 以i为root的解, 而是有效的node为i个的解. 譬如在for loop到2, 即以2为root的情况下, lway只能是1个有效的node, rway则是有2个有效的node. 所以<code>lway = rec(2-1); rway = rec(4-2)</code>.</li>
</ol>
</li>
<li>所以我觉得这个题目相当有意思. 而且思路很清晰.</li>
</ul>
<h3 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h3><ul>
<li>目前只看到N00t是用了recursion和DP来解决.<h4 id="recursion解法">recursion解法</h4></li>
<li>和分析的一样, 遍历l-&gt;r, 让每一个都有机会做root, 然后Divide递归左右子树的所有可能性(所以返回值是<code>List&lt;TreeNode&gt;</code>, 即以TreeNode的有效的BST). 然后Conquer遍历所有有效左右子树, 并接上Node(i).</li>
<li>有几点要注意:<ol>
<li>正如Effective java item 43所说: return empty list rather than null.<ul>
<li>这是一般情况下的trick. 而且这里还有她的实际意义: 即空树的root. 这样在接上Node(i)的时候, 是接上空树. 因为for each的时候一定要能see到空树. 而如果在l&gt;r的时候返回null, 而不是res.add(null)的话, 就直接忽略了空树的情况. 更重要的是: 根源上避免了判断Null pointer. 如果我return null的话, 会出现<code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></li>
</ul>
</li>
<li>在Conquer的时候, 要记住每一组left/right subtree要接上一个new TreeNode(i). 因为是一个新的以i为root的BST.</li>
<li>设计return value为List<treenode>. 例如n=3的话, 最终返回的结果是[1,1,2,3,3]. 实际上是5个不同的BST. 这里我call了writeBST. 果然可以看到返回了5个serialize的BST: <code>[1, #, 3, 2, #, #, #]</code></treenode></li>
</ol>
</li>
</ul>
<h4 id="DP解法">DP解法</h4><ul>
<li>注意到recursion的时候, 例如n=4的情况. [1,2]就给recursion了好几次: [1,2,3], [1,2]. 所以明显是可以保存计算过的结果来DP.</li>
<li>但是具体怎么写呢? 先搞懂N00t的思路. 但实际写起来很多地方要注意:<ul>
<li>虽然说是T[i,l]. 但实际上N00t是用的list<list<list<treenode>&gt;&gt;来写. 原因很简单. 就是前2个保存i和l. 最后一个保存T[i,l], 即满足这个range的BST的root和合集. 因为有了root, 就能得到tree(所以我在main里面最后call了writeBST()来serialize每个BST).</list<list<treenode></li>
<li>边界条件很简单, 就是l=0.</li>
<li>那么打表是怎么个打法. 在interleaving string的DP的设计是T[i][j]. 分别是2个string的坐标, 所以无所谓哪个是外层,哪个是内层循环. 但是这里是T[i][l]. 这个l是长度. N00t的设计是<strong>外层是l, 内层是i</strong>. 所以是按照starting point分类的. 为什么这样loop呢?</li>
</ul>
</li>
</ul>
<h3 id="Serialize/De-serialize_Binary_Tree">Serialize/De-serialize Binary Tree</h3><ul>
<li>先是什么是serialize/deserialize. 可以看水中的鱼的图解: <a href="http://7xj2zx.com1.z0.glb.clouddn.com/freq1_serilizeBinTreeYUBlog.PNG" target="_blank" rel="external">水中的鱼花树</a></li>
<li>pre-order traverse的一个应用. 从而可以解决isValidBST. 而且这个在Leetcode的Binary Tree很常见.</li>
<li>为什么Deserialize也是用pre-order呢? 这个顺序不会反吗? 感觉上觉得应该使用serialize的相反的traverse—&gt;post-order. 但这样其实是不对的. 见<a href="http://yuanhsh.iteye.com/blog/2171113" target="_blank" rel="external">ITeye的分析</a>. 这里我一开始做的方法也是使用的index来判断是读取list中的第几个字符. 但这里我就搞混了: 到底对于right subtree的index该用多少.<ul>
<li>水中的鱼使用了一个int[1]. 然后java当作object, 可以传值. 而且也就避免了return.</li>
<li>我则是用的int, 所以必须return. 所以在left算完之后return的cnt必须是对应left subtree的最后一个node. return之后, right recursion的时候这个index还要再加一. 并且右子树结束后还要return给他的parent(注意这就是recursion后的code的意义: 往上走)</li>
<li>1337原帖后面又一个Java写的. 我改了一点. 使用了stringTokenizer. 也是对的, 而且他并没有使用index来定位这个char, 而是使用了boolean left. 然后每次就是nextToken(). 也是可以的.</li>
</ul>
</li>
</ul>
<h3 id="Binary_Tree_Level_Order_Traversal_II">Binary Tree Level Order Traversal II</h3><h3 id="Triangle">Triangle</h3><hr>
<table>
<thead>
<tr>
<th>ID</th>
<th>Question</th>
<th>freq</th>
</tr>
</thead>
<tbody>
<tr>
<td>58</td>
<td>Length of Last Word</td>
<td>1</td>
</tr>
<tr>
<td>100</td>
<td>Same Tree</td>
<td>1</td>
</tr>
<tr>
<td>104</td>
<td>Maximum Depth of Binary Tree</td>
<td>1</td>
</tr>
<tr>
<td>111</td>
<td>Minimum Depth of Binary Tree</td>
<td>1</td>
</tr>
<tr>
<td>126</td>
<td>Word Ladder II</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>Longest Common Prefix</td>
<td>1</td>
</tr>
<tr>
<td>118</td>
<td>Pascal’s Triangle</td>
<td>1</td>
</tr>
<tr>
<td>119</td>
<td>Pascal’s Triangle II</td>
<td>1</td>
</tr>
<tr>
<td>121</td>
<td>Best Time to Buy and Sell Stock</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>ZigZag Conversion</td>
<td>1</td>
</tr>
<tr>
<td>16</td>
<td>3Sum Closest</td>
<td>1</td>
</tr>
<tr>
<td>30</td>
<td>~~Substring with Concatenation of All Words</td>
<td>1</td>
</tr>
<tr>
<td>71</td>
<td>~~Simplify Path</td>
<td>1</td>
</tr>
<tr>
<td>96</td>
<td>~~Unique Binary Search Trees</td>
<td>1</td>
</tr>
<tr>
<td>107</td>
<td>~~Binary Tree Level Order Traversal II</td>
<td>1</td>
</tr>
<tr>
<td>120</td>
<td>~~Triangle</td>
<td>1</td>
</tr>
<tr>
<td>122</td>
<td>~~Best Time to Buy and Sell Stock II</td>
<td>1</td>
</tr>
<tr>
<td>32</td>
<td>Longest Valid Parentheses</td>
<td>1</td>
</tr>
<tr>
<td>95</td>
<td>Unique Binary Search Trees II</td>
<td>1</td>
</tr>
<tr>
<td>123</td>
<td>Best Time to Buy and Sell Stock III</td>
<td>1</td>
</tr>
<tr>
<td>60</td>
<td>Permutation Sequence</td>
<td>1</td>
</tr>
<tr>
<td>金庸</td>
<td>飞雪连天射白鹿</td>
<td>小虾米</td>
</tr>
</tbody>
</table>

	
	</div>
  <a type="button" href="/2015/01/16/Leetcode/highFreq/Freq1/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-15 </div>
			<div class="article-title"><a href="/2015/01/15/Leetcode/LeetcodeBlogs/" title="A collection of Hello World applications from helloworld.org.">Leetcode的题解收集</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="20150512">20150512</h2><ul>
<li>这个博客一直有更新Leetcode新题的题解报告不错: <a href="http://pisxw.com/tag/" target="_blank" rel="external">一丝凉意</a></li>
</ul>
<h2 id="20150508">20150508</h2><blockquote>
<p>今天做Scramble string的时候看到了很多很好的分析.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/whuwangyi/article/details/43112895" target="_blank" rel="external">武大的wangyi大牛</a>. 不但是很好的Leetcode题解. 而且还是FLAG面经大牛.</li>
<li><a href="http://blog.unieagle.net/" target="_blank" rel="external">Unieagel的leetcode题解博客</a></li>
<li><a href="http://blog.csdn.net/fightforyourdream/article/details/17707187" target="_blank" rel="external">Fightingforyourdream题解CSDN</a></li>
</ul>
<h2 id="20150507">20150507</h2><ul>
<li>fgdsb大牛做的<a href="http://www.fgdsb.com/" target="_blank" rel="external">在Leetcode122题和不在Leetcode的题目153题blog</a></li>
</ul>
<h2 id="20150426">20150426</h2><ul>
<li>ACM之家的Leetcode题解和很多算法题目的分析/题解(Java) <a href="http://www.acmerblog.com/leetcode-solutions-6422.html" target="_blank" rel="external">link</a></li>
<li><a href="http://www.cnblogs.com/lautsie/p/3371354.html" target="_blank" rel="external">刚去了Google的大牛的题集link</a>. 看看她的Google面试准备帖子.</li>
</ul>
<h2 id="20150421">20150421</h2><ul>
<li><a href="http://blog.csdn.net/fightforyourdream/article/details/12901505" target="_blank" rel="external">CSDN fightfordream的Leetcode整理</a>. 而且他还有DP/Recursion/Backtracking题集. 等等. 挺不错的.</li>
</ul>
<h2 id="20150324">20150324</h2><ul>
<li><a href="http://yishafang.blogspot.com/2015/02/triangle.html" target="_blank" rel="external">2个月刷完LC的blog</a>. 要向别人学习努力.</li>
</ul>
<h2 id="20150317">20150317</h2><ul>
<li><a href="http://blog.csdn.net/linhuanmars/article/details/20888505" target="_blank" rel="external">Ganker大神的lc解题报告</a> 要做到这个程度: 算法的分析和比较. 题目类型要心中有数, 信手拈来!</li>
</ul>
<h2 id="20150311">20150311</h2><ul>
<li><a href="http://okckd.github.io/blog/categories/leetcode/" target="_blank" rel="external">okckd的leetcode 175/CC150题解合集以及大量OOP问题整理</a>: 而且有个bonus就是他的题目加了编号和link, 所以方便我在freq里面找. </li>
</ul>
<h2 id="20150301">20150301</h2><ul>
<li>主页君的LC解答分析了他人的做法, 也有总结. Java.<a href="http://www.cnblogs.com/yuzhangcmu/p/4113462.html" target="_blank" rel="external">主页君的Leetcode/Lintcode解答</a></li>
</ul>
<h2 id="20150228">20150228</h2><ul>
<li>看了很多多人有不同的解法. 思路来说, 还是官方自己的答案最好, 每道题都有详细的分析和图解. <a href="http://leetcode.com/2010/11/largest-binary-search-tree-bst-in_22.html" target="_blank" rel="external">1337c0d3r的答题贴</a></li>
</ul>
<h2 id="20150215">20150215</h2><ul>
<li>当然还有LeetCode官方出的clean code handbook. 今天是1.0.3. 只有50题的答案和分析, 但是也有善良点. 比如edit distance分析了答案和经典DP algs的优劣.</li>
</ul>
<h2 id="20150129">20150129</h2><ul>
<li>200题Leetcode Java解答, 而且还有<a href="http://leetcode.tgic.me/" target="_blank" rel="external">题解报告</a>和<a href="https://github.com/tg123/leetcode" target="_blank" rel="external">github连接</a></li>
<li>200题Leetcode C++11解答, 左耳朵耗子大神的<a href="https://github.com/haoel/leetcode" target="_blank" rel="external">github解答</a></li>
</ul>
<h2 id="20141111">20141111</h2><ul>
<li><a href="http://leetcodesummary.blogspot.com/2013/09/leetcode-dfs.html" target="_blank" rel="external">Leetcode总结提炼</a></li>
<li>codeMonkey<a href="http://okckd.github.io/blog/2014/06/12/NineChap-Permutation" target="_blank" rel="external">九章算术Leetcode, Design分析, CC150题解</a></li>
</ul>
<h2 id="20141102">20141102</h2><ul>
<li><a href="http://blog.csdn.net/fightforyourdream/article/details/19755859" target="_blank" rel="external">leetcode答案总结(Java)</a></li>
<li><a href="http://yucoding.blogspot.com/2013/08/leetcode-question-127-word-ladder.html" target="_blank" rel="external">leetcode答案分析</a></li>
</ul>
<h2 id="20141029)">20141029)</h2><ul>
<li><a href="http://bowang.name/leetcode-150/" target="_blank" rel="external">leetcode总结</a></li>
<li><a href="http://www.douban.com/note/330562764" target="_blank" rel="external">leetcode分类</a></li>
<li><a href="http://goo.gl/etltPX" target="_blank" rel="external">leetcode分析</a></li>
<li><a href="http://www.danielbit.com/blog/puzzle/leetcode/leetcode-summary" target="_blank" rel="external">leetcode分类</a></li>
<li><a href="http://www.uuiy.cn/?p=127" target="_blank" rel="external">leetcode总结</a></li>
<li><a href="http://leetcodenotes.wordpress.com" target="_blank" rel="external">leetcode答案</a></li>
<li><a href="https://github.com/openinx/algorithm-solution/tree/master/leetcode" target="_blank" rel="external">leetcode总结</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/" target="_blank" rel="external">leetcode答案(分析详细)</a></li>
<li><a href="http://www.cnblogs.com/wwwjieo0/p/3452930.html" target="_blank" rel="external">leetcode答案</a></li>
</ul>
<h2 id="20141006:">20141006:</h2><ul>
<li>1p3a今天有人问答案，然后大牛门的回答: <a href="http://yucoding.blogspot.com" target="_blank" rel="external">http://yucoding.blogspot.com</a></li>
</ul>
<h2 id="20140928">20140928</h2><ul>
<li><a href="http://www.meetqun.com/thread-703-1-1.html" target="_blank" rel="external">米群网的刷题汇总贴</a></li>
<li><a href="http://www.1point3acres.com/bbs/thread-97234-1-1.html" target="_blank" rel="external">1p3a上面CMU ebiz的Leetcode/CC150 java合集</a></li>
</ul>
<h2 id="20140424">20140424</h2><ul>
<li><a href="https://www.zybuluo.com/smilence/note/76" target="_blank" rel="external">段公子的编程笔记</a></li>
<li>[段公子的励志贴](<a href="http://www.mitbbs.com/article_t/JobHunting/32594745.html" target="_blank" rel="external">http://www.mitbbs.com/article_t/JobHunting/32594745.html</a></li>
<li><a href="https://github.com/iphkwan/leetcode" target="_blank" rel="external">Leetcode Github 答案1</a>          c++</li>
<li><a href="https://github.com/fanfank/leetcode" target="_blank" rel="external">Leetcode Github 答案2</a>           C++</li>
<li><a href="http://fisherlei.blogspot.com/2012/12/leetcode-remove-duplicates-from-sorted_5307.html" target="_blank" rel="external">Leetcode 水中的鱼</a>         c++</li>
<li><a href="http://n00tc0d3r.blogspot.com/2013/05/remove-duplicates-from-sorted-list.html" target="_blank" rel="external">n00tc0d3r博客(多种解法)</a>                 java  </li>
<li><a href="https://github.com/starforever/leet-code/blob/master/Remove%20Duplicates%20from%20Sorted%20Array/Solution.java" target="_blank" rel="external">github starforever</a></li>
</ul>

	
	</div>
  <a type="button" href="/2015/01/15/Leetcode/LeetcodeBlogs/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-15 </div>
			<div class="article-title"><a href="/2015/01/15/thinking/AwesomeCourses/" title="A collection of Hello World applications from helloworld.org.">Awesome Courses</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Introduction">Introduction</h2><p>This is an addition to the well done awesome courses by <a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="external">Prakhar1989-github</a>. And here is for the algorithm specifically.</p>
<h2 id="Table_of_Contents">Table of Contents</h2><ul>
<li><a href="#systems">Systems</a></li>
<li><a href="#programming-languages--compilers">Programming Languages / Compilers</a></li>
<li><a href="#algorithms">Algorithms</a></li>
<li><a href="#cs-theory">CS Theory</a></li>
<li><a href="#introduction-to-cs">Introduction to CS</a></li>
<li><a href="#machine-learning">Machine Learning</a></li>
<li><a href="#misc">Misc</a></li>
</ul>
<h2 id="Good_courses">Good courses</h2><ul>
<li><a href="https://courses.cs.washington.edu/courses/cse373/13wi/lectures.shtml#today" target="_blank" rel="external">cs.washington.CSE373</a>. <ul>
<li>this is a undergrad level data structure class, so not much algs, but I found the sorting is useful. And as <strong>Code Ganker</strong> said, a lot of important algs ideas lies behind basic sorting algs: recursion, DP, D&amp;C, trade-off, etc, you name it.</li>
</ul>
</li>
</ul>

	
	</div>
  <a type="button" href="/2015/01/15/thinking/AwesomeCourses/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-15 </div>
			<div class="article-title"><a href="/2015/01/15/Web/hexoBuilt/" title="Nice Hexo and Freemind">Hexo搭建的经历和问题</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="20150519">20150519</h2><h3 id="怎么更好的贴代码?">怎么更好的贴代码?</h3><ul>
<li><p>我想在每一个解题报告里面加入github, 有什么好的办法呢? 主要是想能在作业部落里面好改的.</p>
<ul>
<li>gist-it. —-&gt;但是悲催的不支持有中文的代码文件…</li>
<li><code>&lt;script url-to-gist /script&gt;</code>  ——&gt; 只支持gist</li>
<li>data-file-folder —-&gt;不知道怎么用, 这样不好移植…</li>
<li>自带的. <a href="http://blog.bd17kaka.net/blog/2012/11/29/octopress-sharing-code-snippets/" target="_blank" rel="external">地址设置参考link</a></li>
</ul>
</li>
<li><p>加入Github代码:</p>
<figure class="highlight ruby"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">_</span>.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="status">=&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试gist:</p>
<script src="https://gist.github.com/4505639.js?file=macroBuild.scala" type="text/javascript">
</script>

</li>
</ul>
<script src="//gist.github.com/b55b0f8f994bbe156e86.js?file=testEmb.java"></script>
<ul>
<li><p>使用gist-it: 保存所有.java代码为utf8就OK了.</p>
<script src="http://gist-it.appspot.com/https://github.com/vlsi1217/vlsi1217.github.io/blob/source/_codes/freq2_tony_chinese/LargestRecHistoOneStack.java">
</script>
</li>
<li><p>内嵌代码: <del>悲催的不支持中文. 看来以后还是得使用英文</del> 并不是, 而是必须所有文件使用UTF-8 without BOM保存. 这样gist-it跟include_code都能正常识别. 因为js/python不支持其他保存格式</p>
<figure class="highlight java"><figcaption><span>FourSum.java</span><a href="/_codes/freq2_tony_chinese/FourSum.java">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> freq2_tony;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 还是二分的思想解决大问题.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourSum</span> </span>{</span><br><span class="line">  <span class="javadoc">/**</span><br><span class="line">   *</span><br><span class="line">   *<span class="javadoctag"> @param</span> num</span><br><span class="line">   *<span class="javadoctag"> @param</span> target</span><br><span class="line">   *<span class="javadoctag"> @return</span></span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSumN00t(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>  (num == <span class="keyword">null</span> || num.length &lt; <span class="number">4</span>)</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num.length-<span class="number">3</span> &amp;&amp; num[i] &lt;= target; ++i) {</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; num.length-<span class="number">2</span>; ++j) {</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; num[j] == num[j-<span class="number">1</span>])</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = j+<span class="number">1</span>, r= num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)  {</span><br><span class="line">          <span class="keyword">int</span> sum = num[i] + num[j] + num[l] + num[r];</span><br><span class="line">          <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">            l++;</span><br><span class="line">          }</span><br><span class="line">          <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sum &gt; target)</span> </span>{</span><br><span class="line">            r--;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span> {</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            cur.add(num[i]);</span><br><span class="line">            cur.add(num[j]);</span><br><span class="line">            cur.add(num[l]);</span><br><span class="line">            cur.add(num[r]);</span><br><span class="line">            res.add(cur);</span><br><span class="line">            do {</span><br><span class="line">              l++;</span><br><span class="line">            } <span class="keyword">while</span> (l &lt; r &amp;&amp; num[l] == num[l-<span class="number">1</span>]);</span><br><span class="line">            do {</span><br><span class="line">              r--;</span><br><span class="line">            } <span class="keyword">while</span> (l &lt; r &amp;&amp; num[r] == num[r+<span class="number">1</span>]);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FourSum</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] input = {-<span class="number">8</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>};</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = fourSumN00t(input, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = twoSum(input, input.length-1, 4);</span></span><br><span class="line">    System.out.println(res);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    FourSum fs = <span class="keyword">new</span> FourSum();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结一下贴代码">总结一下贴代码</h3><ul>
<li>还是得用github来host代码, 因为gitlab不支持.</li>
<li>使用gist-it还是直接内嵌额?<ul>
<li>其实都是使用的本地代码. 因为github只支持embed gist文件.</li>
<li>如果只是使用_codes来保存代码, 然后在git, 在embed的话, 其实很麻烦. 以为除了hexo d之外, 还要单独git source branch.<del>还不如直接git所有代码到github一个project里面.</del> 不管怎么样, 都是要另外git source branch. 这和单独开一个git repo有区别吗? 有的. 一来: 单独的git repo容易看到, git push简单. 而且和gitpage decouple了.</li>
</ul>
</li>
<li>批量转换western到utf-8, 我使用的是: GB/BIG5/UTF-8 文件编码批量转换程序 1.3. 挺好用的.</li>
<li>在Eclipse里面就设置了default encoding为utf-8. 这样以后就不用写完后, 在转换了. 可以参考一下: <a href="https://ekkescorner.wordpress.com/2009/07/28/howto-change-fileencoding-of-eclipse-projects-osx/" target="_blank" rel="external">Encoding Eclipse osx</a></li>
</ul>
<h2 id="20150513">20150513</h2><ul>
<li>因为主要还是在zybuluo里面写markdown. 写完之后放到Hexo并deploy. 所以就直接用img的链接. 一开始试了一下google drive, 分享链接不太好用(要选择是public的程度). 所以还是使用了七牛. 发现还挺方便的. 而且1G空间很够用了. 而且读取很快. 不错.</li>
<li>所以以后就是图片本地还是放在img文件夹里面. 不过同时上传到七牛. 最好还是压缩一下. 有的图片大于1M了.</li>
</ul>
<h2 id="20150508">20150508</h2><ul>
<li>今天主要的任务是把我的github.io从wiki-in-box搬到了Hexo-Freemind. 感受到了强大的Hexo.</li>
<li>不过其中遇到了不少问题. 所以也用了挺长时间做:<ol>
<li>disque怎么弄? 原来是名字是’abc123’, 而不是’<abc213>‘. 所以造成了无法和我在disqus里面注册的.</abc213></li>
<li>RSS/SiteMap怎么弄? 我本来是按照教程直接npm install这2个plugin. 但是hexo g之后并没有产生atom.xml/sitemap.xml. 然后才发现这个plugin应该安装在hexo/tonyhexo里面, 而不是安装到<code>C:\MOOC\NodeJS_Intro\</code>下面. 所以又倒来倒去.</li>
</ol>
</li>
<li>主要参考的:<ul>
<li><a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/#" target="_blank" rel="external">如何搭建一个独立博客</a>. 这里还讲了如何DNS,</li>
<li><a href="http://baoxiehao.com/2014/05/17/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Hexo博客优化</a>. 这个讲了如何使用google analytics和sitemap的用法.</li>
</ul>
</li>
<li>但是发现Hexo还是有些缺陷:<ul>
<li>例如N00t的博客, 她的search可以实时先是match的blog, 而且还能多种显示博客的形式.</li>
<li>这个markdown和作业部落的不太一样, 不过差别不大就是了.</li>
</ul>
</li>
<li>方式:<ul>
<li>主要是在作业部落上面写好, 然后再放到这个Hexo上面. 因为作业部落确实是markdown很友好. 不过Hexo是我的个人博客. 更大自由.</li>
</ul>
</li>
</ul>

	
	</div>
  <a type="button" href="/2015/01/15/Web/hexoBuilt/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-10 </div>
			<div class="article-title"><a href="/2015/01/10/Leetcode/highFreq/Freq45/" title="A collection of Hello World applications from helloworld.org.">Leetcode freq 4~5</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Leetcode_Freq_4-5">Leetcode Freq 4-5</h1><h2 id="标签（空格分隔）：_leetcode">标签（空格分隔）： leetcode</h2><h2 id="目录">目录</h2><p>[TOC]</p>
<h2 id="20141111">20141111</h2><h3 id="Remove_Element">Remove Element</h3><h3 id="Roman_to_Integer">Roman to Integer</h3><h3 id="Swap_Nodes_in_Pairs">Swap Nodes in Pairs</h3><ul>
<li>List的经典操作: 交换nodes. 注意这里什么不变, 什么变. 以及如何处理边界条件. 头脑要清晰. 意乱就麻烦.</li>
<li>follow up就是freq 2的reverse Nodes K-group<h3 id="Add_Binary">Add Binary</h3><h3 id="Sum_Root_to_Leaf_Numbers">Sum Root to Leaf Numbers</h3><h3 id="Add_Two_Numbers">Add Two Numbers</h3><h3 id="Integer_to_Roman">Integer to Roman</h3></li>
</ul>
<h2 id="20141108">20141108</h2><h3 id="Word_Search">Word Search</h3><h3 id="Decode_Ways">Decode Ways</h3><h3 id="Binary_Tree_Level_Order_Traversal">Binary Tree Level Order Traversal</h3><h3 id="Palindrome_Partitioning">Palindrome Partitioning</h3><h3 id="Sqrt(x)">Sqrt(x)</h3><h3 id="Generate_Parentheses">Generate Parentheses</h3><h3 id="Merge_k_Sorted_Lists">Merge k Sorted Lists</h3><h2 id="20141105：">20141105：</h2><h3 id="1-_word_ladder">1. word ladder</h3><ul>
<li>为什么wordladder用linkedlist来保存distanct？为什么要在for loop加distance并enqueue？为什么<code>!isEmpty</code>的时候pop出来的distance就是对的。<ul>
<li>a. ANS: 可以参考Algs Princeton的BFS正确性证明。每次wordQ 在enqueue的时候都是同样深度的。而且queue的pop（remove and return）保证了distance的正确性。<br>eg：ab-&gt;aa的最短距离。虽然az的话。loop会把distanceQ+1. 但是不同的word话要pop distance。如果不同的话又返回到aa了。<ul>
<li>b. 不过还是觉得不太对劲。如果运气不好一直网az,dz,zz方向走不就成了DFS了？而不是BFS（一层一层的走吗？）.<br>ANS：BFS是搜完距离1的继续搜距离2的。当全部搜完之后call distTo来输出start到end的最近距离。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ab</span><br><span class="line"> /   <span class="string">\</span></span><br><span class="line">aa   az</span><br><span class="line">         <span class="string">\</span></span><br><span class="line">         dz</span><br><span class="line">           <span class="string">\</span></span><br><span class="line">           zz</span><br></pre></td></tr></table></figure>
<h2 id="20141103:">20141103:</h2><h3 id="0-_BFS">0. BFS</h3><ul>
<li>联系看pseudocode来写java。比如Wiki page的BFS (link).</li>
<li>还是学习一下regex方便些。因为Java的replaceall支持regex。而且今天在删除eclipse里面的空行也是用的<code>regex: ^\s*\n</code></li>
</ul>
<h3 id="1-_Word_Ladder">1. Word Ladder</h3><ul>
<li>怎么想到本质一个graph的shortest path呢？<ul>
<li>a. 先是看了yutianzuijin的csdn博客（link）他先是想到2d matrix 然后再想到graph的2种表示方法：<ul>
<li>一. adjacent matrix</li>
<li>二.adjacent list. 然后就可以用graph的BFS来解决。但是时间复杂度又太大了，是O(m<em>dict_size). 其实可以做到O(26</em>m)</li>
</ul>
</li>
<li>b. 鱼的（link）讲了可以用<code>bi-directional BFS</code>，也可以看作是夹逼方法和k-Sum问题类似。</li>
<li>c. n00tc0d3r比较详细的分析并给出不同解法。而且说了hashset/hashmap在Java和C++里面的区别：在Java中map快，在C++中set快。</li>
</ul>
</li>
</ul>
<h2 id="20141102:">20141102:</h2><blockquote>
<p>finish freq 5</p>
</blockquote>
<h3 id="1-_set_Matrix_Zeros-">1.  set Matrix Zeros.</h3><ul>
<li>这又是一道：达到目的可以改变方式。为了in place.</li>
<li>必须要有2组set来记录行列为0的info。既然有matrix给我们。就可以改变它。为什么不用第一行列作为这个row/col set. 当然如果第一行列有zero怎么回忆起来呢？虽说inplace不能用additional set. 但是flag还是可以的。因为O(1)=in place。</li>
</ul>
<h3 id="2-_Merge_sorted_array/list-">2. Merge sorted array/list.</h3><p>复习一下java里面的lnkedlist和指针了。</p>
<h2 id="20141101:">20141101:</h2><h3 id="1-_Pow(x,n):">1. Pow(x,n):</h3><p>我看了n00tc的答案，他是用n&gt;&gt;1 和 n&amp;1来代替除法和取余数。但是我直接把pow2的计算换成bit后答案就错了。为什么呐？我测试了一下&gt;&gt;1 跟 &amp;1. 发现如果是正数当然没问题。但如果是负数则除法跟取模都会得到意外的答案。</p>
<ol>
<li>I got yu shu: 1 vs 1</li>
<li>I got remainder: 1 vs 1</li>
<li>I got yu shu: -1 vs -2</li>
<li>I got remainder: -1 vs 1<br>注意到N00tc0d3r一开始就把指数n取了绝对值。</li>
</ol>
<h3 id="2-_Validate_BST">2. Validate BST</h3><p>很好的题目。可以复习到recursion跟iteration的转化。其实traverse里面的迭代版本不好想。邓俊辉的教材分析得很详细。而且recursion里面的每个return只是结束当前的stack，从而可以继续之前保存的stack。觉得CMU-ebiz的答案最好懂。这里面的lastVisit = root.val放到if(root.val&lt;=lastVisit)之后。这个顺序也是一个高潮。要真正理解recursion才能想出来这点。</p>
<h3 id="3-_kd-Tree-">3.  kd-Tree.</h3><ul>
<li>参见Coursera Algo4th 的作业五：在一堆点里面找能用一个unit square抱住的点群。这就需要用2d tree来search了。link</li>
</ul>
<h3 id="4-_Palindrome">4.  Palindrome</h3><ul>
<li>做palindrome之前先看一下java的replaceall用的regex: <a href="">link</a></li>
<li>这里要了解的就是[^a-z], [a-z0-3]的意思。前者是除了a到z以外。后者表示a到z和0到3.所以这里就是先把输入的string的非字母数字的字符都换成”“。</li>
</ul>
<h3 id="5-_Valid_Number">5. Valid Number</h3><ul>
<li>居然说Valid Number是难度2的题目。。。跪了。第一次面试做compiler的parser就是一个automa。然后不会写Java的状态机。这次一定要搞懂。记得moore和mooley FSM最难的就是设计states。就连最简单的判断100101都容易写错。可以参考这个link看看这个状态图是怎么画的。N00tc0d3r只给了图….</li>
<li>注意switch case的格式：要在每个case最后加break或者return。而且case只能是每一个值而不能给范围。所以a-zA-Z0-9就呆了。还是if else好用些。</li>
</ul>
<h3 id="6-_setMatrixZeros">6. setMatrixZeros</h3><ul>
<li>做setMatrixZeros看到用的hashset，为什么呢？hashmap不行吗？为什么用<code>Set&lt;Integer&gt; rows = new HashSet&lt;Integer&gt;();</code><br>然后看到了一片总结：link。<br>可以看看我在CS108里面贴的那个java collection framework关系图。<br>注意在jdk里面set.class和hashset.class. 前者是interface后者是implementation。</li>
</ul>
<h2 id="20141030:">20141030:</h2><h3 id="0-_climb_chairs">0. climb chairs</h3><p>这题和数硬币组合类似。不过前者是permutation后者为combination。</p>
<h3 id="1-_2_sum:">1. 2 sum:</h3><p>首先把题意搞清楚:<br>输入是一组未排序的可重复数组，以及一个目标数。且一组数组只有一组解。求这两个数的index。</p>
<p>ANS:<br>一开始想是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i:<span class="instruction"> array</span><br><span class="line"></span>     for: j: rest of<span class="instruction"> array</span><br><span class="line"></span>         <span class="instruction"> if </span>(i+j==target<span class="function">)</span></span><br><span class="line">               return.</span><br></pre></td></tr></table></figure></p>
<p>但是这样就会得到O(n^2)!</p>
<p>记得quick sort之类的排序算法是O(nlgn)。可以得到吗。<br>唉。想不出来。<br>看网上答案也就n00tc03r和lexi女的博客有思路分析。还有CMU-ebiz的java整个打包但是答案质量一般。不过也可以看看。programcreek的也很好。</p>
<p>但最主要还是像段公子说的那样要总结分析出pattern而不是一题一题的解决。这样永远会有不会做“新题”的可能。</p>
<p>比如这里面一般C++的都会用头尾指针，如CMU的做法。这里有个分析点很重要：首位指针如果大于target则可以把大的元素永远排除！也很容易想：因为这个最大的数加上最小的那个数都超了，那他就不可能和任意其他元素相加得到target。但是小的那个数却可以保留。因为他还有机会。这里和merge 2个排好序的数组要从最后排起。以及删除一个linked list的node却只给了前一个pointer一样。要脑子拐过弯！</p>
<p>所以先写第二种解法：头尾指针往中间靠。这样的时间复杂度是多少呢？<br>仔细看一下。CC里面的2sum是return 满足条件的2个element的值。所以可以用java的sort。<br>但因为leetcode是要求index。所以要多一个O(N)空间复杂度来保存index。<br>九章和CMU_ebiz都给了这个答案。</p>
<p>第三种解法：用hashmap。则可以O(1)+O(n)=O(n)<br>一个for loop, 搜索map里面有没满足的数，途中把target-input[i] 放到map里面。<br>这个最好。用到了java的library。又快又方便啊！而且HashTable解决所有搜索问题啊。</p>
<h3 id="2-_3_sum：">2. 3 sum：</h3><p>还是要把题目理解：<br>找到一组未排序的可重复数组里面的所有 不重复的满足sum为0的triplets。<br>艹，搞了一上午，为什么Java ArrayList<arraylist<integer>&gt; remains empty when I add an ArrayList<integer>. 原来是ret.add(each)的不是copy而是reference。在each.clear()后，前一句的2D list add就是add了一个空的ArrayList。正如Core Java里面讲的：“parameters to java methods are always passed by value. The value of any object variable is a reference to an object that stored elsewhere.<br>中饭回来查了一发现stack overflow上有这个解答：link<br>所以有2个方法解决clear就把之前added的删去的问题：<br>     a. 用add new（each） 也就是copy过来。<br>     b. 每次在inner loop里面new一个each。</integer></arraylist<integer></p>
<h3 id="3-_3_sum_closest">3. 3 sum closest</h3><h3 id="4-_4_sum">4. 4 sum</h3><h3 id="5-_k-sum-">5. k-sum.</h3><h3 id="6-pow(x,n)：">6.pow(x,n)：</h3><p>先是naive做法。直接循环。但是傻了，忘了负指数是取倒数了。<br>到了用naive的recursion做法，Programcreek是说：’a recursive solution can easily be written.’。。。好容易弄混。要好好分类。其实就3类，先按N的奇偶正负分，同时和x的正负。而且记住是recursion，所以三个case都是互相调用，每次调用都是<code>pow*pow*pow</code>！而不是pow一次。<br>但是naive的recursion还是不够快，而且recursion的重复计算总是不好的。</p>
<hr>
<table>
<thead>
<tr>
<th>ID</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>27</td>
<td>Remove Element</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>13</td>
<td>Roman to Integer</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>24</td>
<td><del>Swap Nodes in Pairs</del></td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>67</td>
<td>Add Binary</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>129</td>
<td>Sum Root to Leaf Numbers</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td><del>Add Two Numbers</del></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>12</td>
<td>Integer to Roman</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>22</td>
<td>Generate Parentheses</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>23</td>
<td>Merge k Sorted Lists</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>46</td>
<td><del>Permutations</del></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>49</td>
<td><del>Anagrams</del></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>77</td>
<td><del>Combinations</del></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>78</td>
<td><del>Subsets</del></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>79</td>
<td>Word Search</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>91</td>
<td>Decode Ways</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>102</td>
<td>Binary Tree Level Order Traversal</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>131</td>
<td>Palindrome Partitioning</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>69</td>
<td>Sqrt(x)</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td><del>Two Sum</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>8</td>
<td><del>String to Integer (atoi)</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>20</td>
<td><del>Valid Parentheses</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>21</td>
<td><del>Merge Two Sorted Lists</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>65</td>
<td><del>Valid Number</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>70</td>
<td><del>Climbing Stairs</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>88</td>
<td><del>Merge Sorted Array</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>125</td>
<td><del>Valid Palindrome</del></td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>15</td>
<td><del>3Sum</del></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>50</td>
<td><del>Pow(x, n)</del></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>73</td>
<td><del>Set Matrix Zeroes</del></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>98</td>
<td><del>Validate Binary Search Tree</del></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>127</td>
<td><del>Word Ladder</del></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>28</td>
<td><del>Implement strStr()</del></td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>56</td>
<td><del>Merge Intervals</del></td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>57</td>
<td><del>Insert Interval</del></td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>ID</td>
<td>念念不忘, 必有回响</td>
<td></td>
</tr>
</tbody>
</table>

	
	</div>
  <a type="button" href="/2015/01/10/Leetcode/highFreq/Freq45/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-01 </div>
			<div class="article-title"><a href="/2015/01/01/Leetcode/Frequency/" title="A collection of Hello World applications from helloworld.org.">Leetcode 高频题 频率表</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Leetcode_高频题_频率表">Leetcode 高频题 频率表</h1><p>标签（空格分隔）： leetcode</p>
<hr>
<p>[TOC]</p>
<table>
<thead>
<tr>
<th>Leetcode</th>
<th>Questions</th>
<th></th>
<th></th>
<th>一代</th>
<th>宗师</th>
</tr>
</thead>
<tbody>
<tr>
<td>题号</td>
<td>QUESTION</td>
<td>难度</td>
<td>频率</td>
<td>数据结构</td>
<td>算法</td>
</tr>
<tr>
<td>58</td>
<td>Length of Last Word</td>
<td>1</td>
<td>1</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>Same Tree</td>
<td>1</td>
<td>1</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>104</td>
<td>Maximum Depth of Binary Tree</td>
<td>1</td>
<td>1</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>111</td>
<td>Minimum Depth of Binary Tree</td>
<td>1</td>
<td>1</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>126</td>
<td>Word Ladder II</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>Longest Common Prefix</td>
<td>2</td>
<td>1</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>118</td>
<td>Pascal’s Triangle</td>
<td>2</td>
<td>1</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>119</td>
<td>Pascal’s Triangle II</td>
<td>2</td>
<td>1</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>121</td>
<td>Best Time to Buy and Sell Stock</td>
<td>2</td>
<td>1</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>6</td>
<td>ZigZag Conversion</td>
<td>3</td>
<td>1</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>3Sum Closest</td>
<td>3</td>
<td>1</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>30</td>
<td>Substring with Concatenation of All Words</td>
<td>3</td>
<td>1</td>
<td>string</td>
<td>two pointers</td>
</tr>
<tr>
<td>71</td>
<td>Simplify Path</td>
<td>3</td>
<td>1</td>
<td>string</td>
<td>stack</td>
</tr>
<tr>
<td>96</td>
<td>Unique Binary Search Trees</td>
<td>3</td>
<td>1</td>
<td>tree</td>
<td>dp</td>
</tr>
<tr>
<td>107</td>
<td>Binary Tree Level Order Traversal II</td>
<td>3</td>
<td>1</td>
<td>tree</td>
<td>bfs</td>
</tr>
<tr>
<td>120</td>
<td>Triangle</td>
<td>3</td>
<td>1</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>122</td>
<td>Best Time to Buy and Sell Stock II</td>
<td>3</td>
<td>1</td>
<td>array</td>
<td>greedy</td>
</tr>
<tr>
<td>32</td>
<td>Longest Valid Parentheses</td>
<td>4</td>
<td>1</td>
<td>string</td>
<td>dp</td>
</tr>
<tr>
<td>95</td>
<td>Unique Binary Search Trees II</td>
<td>4</td>
<td>1</td>
<td>tree</td>
<td>dp, dfs</td>
</tr>
<tr>
<td>123</td>
<td>Best Time to Buy and Sell Stock III</td>
<td>4</td>
<td>1</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>60</td>
<td>Permutation Sequence</td>
<td>5</td>
<td>1</td>
<td></td>
<td>permutation, math</td>
</tr>
<tr>
<td>85</td>
<td>Maximal Rectangle</td>
<td>5</td>
<td>1</td>
<td>array</td>
<td>dp, stack</td>
</tr>
<tr>
<td>66</td>
<td>Plus One</td>
<td>1</td>
<td>2</td>
<td>array</td>
<td>math</td>
</tr>
<tr>
<td>101</td>
<td>Symmetric Tree</td>
<td>1</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>110</td>
<td>Balanced Binary Tree</td>
<td>1</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>9</td>
<td>Palindrome Number</td>
<td>2</td>
<td>2</td>
<td></td>
<td>math</td>
</tr>
<tr>
<td>35</td>
<td>Search Insert Position</td>
<td>2</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>Valid Sudoku</td>
<td>2</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>Count and Say</td>
<td>2</td>
<td>2</td>
<td>string</td>
<td>two pointers</td>
</tr>
<tr>
<td>80</td>
<td>Remove Duplicates from Sorted Array II</td>
<td>2</td>
<td>2</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>113</td>
<td>Path Sum II</td>
<td>2</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>3</td>
<td>Longest Substring Without Repeating Characters</td>
<td>3</td>
<td>2</td>
<td>string, hashtable</td>
<td>two pointers</td>
</tr>
<tr>
<td>11</td>
<td>Container With Most Water</td>
<td>3</td>
<td>2</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>18</td>
<td>4Sum</td>
<td>3</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td>Jump Game</td>
<td>3</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>59</td>
<td>Spiral Matrix II</td>
<td>3</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>Rotate List</td>
<td>3</td>
<td>2</td>
<td>linked list</td>
<td>two pointers</td>
</tr>
<tr>
<td>92</td>
<td>Reverse Linked List II</td>
<td>3</td>
<td>2</td>
<td>linked list</td>
<td>two pointers</td>
</tr>
<tr>
<td>5</td>
<td>Longest Palindromic Substring</td>
<td>4</td>
<td>2</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>Reverse Nodes in k-Group</td>
<td>4</td>
<td>2</td>
<td>linked list</td>
<td>recursion, two pointers</td>
</tr>
<tr>
<td>37</td>
<td>Sudoku Solver</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>dfs</td>
</tr>
<tr>
<td>40</td>
<td>Combination Sum II</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>combination</td>
</tr>
<tr>
<td>42</td>
<td>Trapping Rain Water</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>two pointers, stack</td>
</tr>
<tr>
<td>45</td>
<td>Jump Game II</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>47</td>
<td>Permutations II</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>permutation</td>
</tr>
<tr>
<td>48</td>
<td>Rotate Image</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>54</td>
<td>Spiral Matrix</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>68</td>
<td>Text Justification</td>
<td>4</td>
<td>2</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>75</td>
<td>Sort Colors</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>sort, two pointers</td>
</tr>
<tr>
<td>76</td>
<td>Minimum Window Substring</td>
<td>4</td>
<td>2</td>
<td>string</td>
<td>two pointers</td>
</tr>
<tr>
<td>89</td>
<td>Gray Code</td>
<td>4</td>
<td>2</td>
<td></td>
<td>combination</td>
</tr>
<tr>
<td>90</td>
<td>Subsets II</td>
<td>4</td>
<td>2</td>
<td>array</td>
<td>recursion, combination</td>
</tr>
<tr>
<td>99</td>
<td>Recover Binary Search Tree</td>
<td>4</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>115</td>
<td>Distinct Subsequences</td>
<td>4</td>
<td>2</td>
<td>string</td>
<td>dp</td>
</tr>
<tr>
<td>117</td>
<td>Populating Next Right Pointers in Each Node II</td>
<td>4</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>124</td>
<td>Binary Tree Maximum Path Sum</td>
<td>4</td>
<td>2</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>31</td>
<td>Next Permutation</td>
<td>5</td>
<td>2</td>
<td>array</td>
<td>permutation</td>
</tr>
<tr>
<td>41</td>
<td>First Missing Positive</td>
<td>5</td>
<td>2</td>
<td>array</td>
<td>sort</td>
</tr>
<tr>
<td>84</td>
<td>Largest Rectangle in Histogram</td>
<td>5</td>
<td>2</td>
<td>array</td>
<td>stack</td>
</tr>
<tr>
<td>87</td>
<td>Scramble String</td>
<td>5</td>
<td>2</td>
<td>string</td>
<td>recursion, dp</td>
</tr>
<tr>
<td>97</td>
<td>Interleaving String</td>
<td>5</td>
<td>2</td>
<td>string</td>
<td>recursion, dp</td>
</tr>
<tr>
<td>26</td>
<td>Remove Duplicates from Sorted Array</td>
<td>1</td>
<td>3</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>83</td>
<td>Remove Duplicates from Sorted List</td>
<td>1</td>
<td>3</td>
<td>linked list</td>
<td></td>
</tr>
<tr>
<td>112</td>
<td>Path Sum</td>
<td>1</td>
<td>3</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>7</td>
<td>Reverse Integer</td>
<td>2</td>
<td>3</td>
<td></td>
<td>math</td>
</tr>
<tr>
<td>19</td>
<td>Remove Nth Node From End of List</td>
<td>2</td>
<td>3</td>
<td>linked list</td>
<td>two pointers</td>
</tr>
<tr>
<td>62</td>
<td>Unique Paths</td>
<td>2</td>
<td>3</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>108</td>
<td>Convert Sorted Array to Binary Search Tree</td>
<td>2</td>
<td>3</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>17</td>
<td>Letter Combinations of a Phone Number</td>
<td>3</td>
<td>3</td>
<td>string</td>
<td>dfs</td>
</tr>
<tr>
<td>39</td>
<td>Combination Sum</td>
<td>3</td>
<td>3</td>
<td>array</td>
<td>combination</td>
</tr>
<tr>
<td>53</td>
<td>Maximum Subarray</td>
<td>3</td>
<td>3</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>63</td>
<td>Unique Paths II</td>
<td>3</td>
<td>3</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>64</td>
<td>Minimum Path Sum</td>
<td>3</td>
<td>3</td>
<td>array</td>
<td>dp</td>
</tr>
<tr>
<td>74</td>
<td>Search a 2D Matrix</td>
<td>3</td>
<td>3</td>
<td>array</td>
<td>binary search</td>
</tr>
<tr>
<td>82</td>
<td>Remove Duplicates from Sorted List II</td>
<td>3</td>
<td>3</td>
<td>linked list</td>
<td>recursion, two pointers</td>
</tr>
<tr>
<td>86</td>
<td>Partition List</td>
<td>3</td>
<td>3</td>
<td>linked list</td>
<td>two pointers</td>
</tr>
<tr>
<td>93</td>
<td>Restore IP Addresses</td>
<td>3</td>
<td>3</td>
<td>string</td>
<td>dfs</td>
</tr>
<tr>
<td>105</td>
<td>Construct Binary Tree from Preorder and Inorder Tr</td>
<td>3</td>
<td>3</td>
<td>array, tree</td>
<td>dfs</td>
</tr>
<tr>
<td>106</td>
<td>Construct Binary Tree from Inorder and Postorder T</td>
<td>3</td>
<td>3</td>
<td>array, tree</td>
<td>dfs</td>
</tr>
<tr>
<td>114</td>
<td>Flatten Binary Tree to Linked List</td>
<td>3</td>
<td>3</td>
<td>tree</td>
<td>recursion, stack</td>
</tr>
<tr>
<td>116</td>
<td>Populating Next Right Pointers in Each Node</td>
<td>3</td>
<td>3</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>29</td>
<td>Divide Two Integers</td>
<td>4</td>
<td>3</td>
<td></td>
<td>binary search, math</td>
</tr>
<tr>
<td>33</td>
<td>Search in Rotated Sorted Array</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td>binary search</td>
</tr>
<tr>
<td>34</td>
<td>Search for a Range</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td>binary search</td>
</tr>
<tr>
<td>43</td>
<td>Multiply Strings</td>
<td>4</td>
<td>3</td>
<td>string</td>
<td>two pointers</td>
</tr>
<tr>
<td>51</td>
<td>N-Queens</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td>dfs</td>
</tr>
<tr>
<td>52</td>
<td>N-Queens II</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td>dfs</td>
</tr>
<tr>
<td>72</td>
<td>Edit Distance</td>
<td>4</td>
<td>3</td>
<td>string</td>
<td>dp</td>
</tr>
<tr>
<td>94</td>
<td>Binary Tree Inorder Traversal</td>
<td>4</td>
<td>3</td>
<td>tree, hashtable</td>
<td>recursion, morris, stack</td>
</tr>
<tr>
<td>103</td>
<td>Binary Tree Zigzag Level Order Traversal</td>
<td>4</td>
<td>3</td>
<td>queue, tree</td>
<td>bfs, stack</td>
</tr>
<tr>
<td>109</td>
<td>Convert Sorted List to Binary Search Tree</td>
<td>4</td>
<td>3</td>
<td>linked list</td>
<td>recursion, two pointers</td>
</tr>
<tr>
<td>128</td>
<td>Longest Consecutive Sequence</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>130</td>
<td>Surrounded Regions</td>
<td>4</td>
<td>3</td>
<td>array</td>
<td>bfs, dfs</td>
</tr>
<tr>
<td>132</td>
<td>Palindrome Partitioning II</td>
<td>4</td>
<td>3</td>
<td>string</td>
<td>dp</td>
</tr>
<tr>
<td>4</td>
<td>Median of Two Sorted Arrays</td>
<td>5</td>
<td>3</td>
<td>array</td>
<td>binary search</td>
</tr>
<tr>
<td>10</td>
<td>Regular Expression Matching</td>
<td>5</td>
<td>3</td>
<td>string</td>
<td>recursion, dp</td>
</tr>
<tr>
<td>44</td>
<td>Wildcard Matching</td>
<td>5</td>
<td>3</td>
<td>string</td>
<td>recursion, dp, greedy</td>
</tr>
<tr>
<td>81</td>
<td>Search in Rotated Sorted Array II</td>
<td>5</td>
<td>3</td>
<td>array</td>
<td>binary search</td>
</tr>
<tr>
<td>27</td>
<td>Remove Element</td>
<td>1</td>
<td>4</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>13</td>
<td>Roman to Integer</td>
<td>2</td>
<td>4</td>
<td></td>
<td>math</td>
</tr>
<tr>
<td>24</td>
<td>Swap Nodes in Pairs</td>
<td>2</td>
<td>4</td>
<td>linked list</td>
<td></td>
</tr>
<tr>
<td>67</td>
<td>Add Binary</td>
<td>2</td>
<td>4</td>
<td>string</td>
<td>two pointers, math</td>
</tr>
<tr>
<td>129</td>
<td>Sum Root to Leaf Numbers</td>
<td>2</td>
<td>4</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>2</td>
<td>Add Two Numbers</td>
<td>3</td>
<td>4</td>
<td>linked list</td>
<td>two pointers, math</td>
</tr>
<tr>
<td>12</td>
<td>Integer to Roman</td>
<td>3</td>
<td>4</td>
<td></td>
<td>math</td>
</tr>
<tr>
<td>22</td>
<td>Generate Parentheses</td>
<td>3</td>
<td>4</td>
<td>string</td>
<td>dfs</td>
</tr>
<tr>
<td>23</td>
<td>Merge k Sorted Lists</td>
<td>3</td>
<td>4</td>
<td>linked list, heap</td>
<td>sort, two pointers, merge</td>
</tr>
<tr>
<td>46</td>
<td>Permutations</td>
<td>3</td>
<td>4</td>
<td>array</td>
<td>permutation</td>
</tr>
<tr>
<td>49</td>
<td>Anagrams</td>
<td>3</td>
<td>4</td>
<td>string, hashtable</td>
<td></td>
</tr>
<tr>
<td>77</td>
<td>Combinations</td>
<td>3</td>
<td>4</td>
<td></td>
<td>combination</td>
</tr>
<tr>
<td>78</td>
<td>Subsets</td>
<td>3</td>
<td>4</td>
<td>array</td>
<td>recursion, combination</td>
</tr>
<tr>
<td>79</td>
<td>Word Search</td>
<td>3</td>
<td>4</td>
<td>array</td>
<td>dfs</td>
</tr>
<tr>
<td>91</td>
<td>Decode Ways</td>
<td>3</td>
<td>4</td>
<td>string</td>
<td>recursion, dp</td>
</tr>
<tr>
<td>102</td>
<td>Binary Tree Level Order Traversal</td>
<td>3</td>
<td>4</td>
<td>tree</td>
<td>bfs</td>
</tr>
<tr>
<td>131</td>
<td>Palindrome Partitioning</td>
<td>3</td>
<td>4</td>
<td>string</td>
<td>dfs</td>
</tr>
<tr>
<td>69</td>
<td>Sqrt(x)</td>
<td>4</td>
<td>4</td>
<td></td>
<td>binary search</td>
</tr>
<tr>
<td>1</td>
<td>Two Sum</td>
<td>2</td>
<td>5</td>
<td>array, set</td>
<td>sort, two pointers</td>
</tr>
<tr>
<td>8</td>
<td>String to Integer (atoi)</td>
<td>2</td>
<td>5</td>
<td>string</td>
<td>math</td>
</tr>
<tr>
<td>20</td>
<td>Valid Parentheses</td>
<td>2</td>
<td>5</td>
<td>string</td>
<td>stack</td>
</tr>
<tr>
<td>21</td>
<td>Merge Two Sorted Lists</td>
<td>2</td>
<td>5</td>
<td>linked list</td>
<td>sort, two pointers, merge</td>
</tr>
<tr>
<td>65</td>
<td>Valid Number</td>
<td>2</td>
<td>5</td>
<td>string</td>
<td>math</td>
</tr>
<tr>
<td>70</td>
<td>Climbing Stairs</td>
<td>2</td>
<td>5</td>
<td></td>
<td>dp</td>
</tr>
<tr>
<td>88</td>
<td>Merge Sorted Array</td>
<td>2</td>
<td>5</td>
<td>array</td>
<td>two pointers, merge</td>
</tr>
<tr>
<td>125</td>
<td>Valid Palindrome</td>
<td>2</td>
<td>5</td>
<td>string</td>
<td>two pointers</td>
</tr>
<tr>
<td>15</td>
<td>3Sum</td>
<td>3</td>
<td>5</td>
<td>array</td>
<td>two pointers</td>
</tr>
<tr>
<td>50</td>
<td>Pow(x, n)</td>
<td>3</td>
<td>5</td>
<td></td>
<td>binary search, math</td>
</tr>
<tr>
<td>73</td>
<td>Set Matrix Zeroes</td>
<td>3</td>
<td>5</td>
<td>array</td>
<td></td>
</tr>
<tr>
<td>98</td>
<td>Validate Binary Search Tree</td>
<td>3</td>
<td>5</td>
<td>tree</td>
<td>dfs</td>
</tr>
<tr>
<td>127</td>
<td>Word Ladder</td>
<td>3</td>
<td>5</td>
<td>graph</td>
<td>bfs, shortest path</td>
</tr>
<tr>
<td>28</td>
<td>Implement strStr()</td>
<td>4</td>
<td>5</td>
<td>string</td>
<td>two pointers, KMP, rolling hash</td>
</tr>
<tr>
<td>56</td>
<td>Merge Intervals</td>
<td>4</td>
<td>5</td>
<td>array, linked list, red-black tree</td>
<td>sort, merge</td>
</tr>
<tr>
<td>57</td>
<td>Insert Interval</td>
<td>4</td>
<td>5</td>
<td>array, linked list, red-black tree</td>
<td>sort, merge</td>
</tr>
<tr>
<td>念念</td>
<td>不忘</td>
<td>必有</td>
<td>回响</td>
<td>王家卫</td>
</tr>
</tbody>
</table>

	
	</div>
  <a type="button" href="/2015/01/01/Leetcode/Frequency/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-16 </div>
			<div class="article-title"><a href="/2014/12/16/OA/ACMresource/" title="记录和ACM有关的学习资料">ACM相关资料</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="学习资料">学习资料</h1><ul>
<li><a href="http://web.stanford.edu/class/cs97si/" target="_blank" rel="external">Stanford CS 97: ICPC培训课程</a></li>
</ul>

	
	</div>
  <a type="button" href="/2014/12/16/OA/ACMresource/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/2/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/4/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Demo/">Demo<span>1</span></a></li>
		
			<li><a href="/categories/Interview/">Interview<span>21</span></a></li>
		
			<li><a href="/categories/Leetcode/">Leetcode<span>4</span></a></li>
		
			<li><a href="/categories/OA/">OA<span>4</span></a></li>
		
			<li><a href="/categories/OS/">OS<span>1</span></a></li>
		
			<li><a href="/categories/Thinking/">Thinking<span>2</span></a></li>
		
			<li><a href="/categories/Web/">Web<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/DC/">DC<span>2</span></a></li>
		
			<li><a href="/tags/Greedy/">Greedy<span>1</span></a></li>
		
			<li><a href="/tags/List/">List<span>1</span></a></li>
		
			<li><a href="/tags/DP/">DP<span>7</span></a></li>
		
			<li><a href="/tags/ACM/">ACM<span>2</span></a></li>
		
			<li><a href="/tags/demo/">demo<span>1</span></a></li>
		
			<li><a href="/tags/OA/">OA<span>2</span></a></li>
		
			<li><a href="/tags/webApp/">webApp<span>1</span></a></li>
		
			<li><a href="/tags/Stack/">Stack<span>1</span></a></li>
		
			<li><a href="/tags/Algorithm/">Algorithm<span>1</span></a></li>
		
			<li><a href="/tags/Ladder/">Ladder<span>7</span></a></li>
		
			<li><a href="/tags/mooc/">mooc<span>1</span></a></li>
		
			<li><a href="/tags/BFS/">BFS<span>1</span></a></li>
		
			<li><a href="/tags/POJ/">POJ<span>1</span></a></li>
		
			<li><a href="/tags/Lintcode/">Lintcode<span>7</span></a></li>
		
			<li><a href="/tags/misc/">misc<span>1</span></a></li>
		
			<li><a href="/tags/NineChap/">NineChap<span>14</span></a></li>
		
			<li><a href="/tags/BinaryTree/">BinaryTree<span>1</span></a></li>
		
			<li><a href="/tags/Leetcode/">Leetcode<span>16</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2015/05/30/Leetcode/Report/Report-LargestRectangleInstagram/"  title="做完九章Ladder" ><i class="fa fa-file-o"></i>Largest rectangle in instag...</a>
      </li>
    
      <li>
        <a href="/2015/05/26/MOOC/Algorithm_JapanBook/Algs-Japan-toc/"  title="Path of learning the book: 挑战程序设计竞赛" ><i class="fa fa-file-o"></i>Algs-Japan-toc...</a>
      </li>
    
      <li>
        <a href="/2015/05/25/Leetcode/Report/Report-Word-Break/"  title="O() != TLE. 同样的O(), 但是实际时间还是会导致TLE" ><i class="fa fa-file-o"></i>Report: Word Break...</a>
      </li>
    
      <li>
        <a href="/2015/05/24/Leetcode/Report/Report-Triangle/"  title="九章算法的学习DP的经典例子" ><i class="fa fa-file-o"></i>Report: Triangle Min Path S...</a>
      </li>
    
      <li>
        <a href="/2015/05/24/Leetcode/Report/Report-Jump-Game-I/"  title="经典的DP, Greedy问题" ><i class="fa fa-file-o"></i>Report: Jump Game I...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/freemind/" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-code"></i><a href="n00tc0d3r.blogspot.com" title="N00t." target="_blank"]);">N00t题解</a></li>
	
		<li><i class="fa fa-code"></i><a href="http://www.shuatiblog.com/" title="" target="_blank"]);">Coding monkey</a></li>
	
		<li><i class="fa fa-code"></i><a href="http://leetcode.tgic.me/" title="" target="_blank"]);">tgic290题解</a></li>
	
		<li><i class="fa fa-code"></i><a href="http://www.fgdsb.com/" title="" target="_blank"]);">fgdsb题解</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://bookshadow.com/leetcode/" title="" target="_blank"]);">书影Leetcode 290题题解</a></li>
	
		<li><i class="fa fa-code"></i><a href="https://sites.google.com/site/jennyshelloworld/company-blog" title="" target="_blank"]);">CMU_Jenny九章算法1笔记</a></li>
	
		<li><i class=""></i><a href="http://www.cnblogs.com/yuzhangcmu/" title="" target="_blank"]);">九章Yu&#39;s Garden</a></li>
	
		<li><i class="fa fa-coffee"></i><a href="http://mindhacks.cn/" title="" target="_blank"]);">暗时间</a></li>
	
		<li><i class="fa fa-coffee"></i><a href="http://coolshell.cn/articles/4990.html" title="" target="_blank"]);">左耳朵耗子</a></li>
	
		<li><i class="fa fa-coffee"></i><a href="http://hehejun.blogspot.com/" title="" target="_blank"]);">呵呵君blog</a></li>
	
		<li><i class="fa fa-coffee"></i><a href="http://zh.lucida.me/blog/on-learning-algorithms/" title="" target="_blank"]);">algs学习之路-lucida</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2015 玉娇龙
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.
</p>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 

<<<<<<< Updated upstream
=======

<script type="text/javascript">
var disqus_shortname = 'vlsi1217';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>

>>>>>>> Stashed changes

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<<<<<<< Updated upstream

=======
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-62877030-1', 'auto');
  ga('send', 'pageview');

</script>
>>>>>>> Stashed changes

</body>
   </html>
