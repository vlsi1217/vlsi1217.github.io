<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[百变千幻衡山云雾十三式]]></title>
  <subtitle><![CDATA[Wikirize my knowledge]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vlsi1217.github.io/"/>
  <updated>2015-10-11T00:31:05.021Z</updated>
  <id>http://vlsi1217.github.io/</id>
  
  <author>
    <name><![CDATA[玉娇龙]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Largest rectangle in instagram 解题报告]]></title>
    <link href="http://vlsi1217.github.io/2015/05/30/Leetcode/Report/Report-LargestRectangleInstagram/"/>
    <id>http://vlsi1217.github.io/2015/05/30/Leetcode/Report/Report-LargestRectangleInstagram/</id>
    <published>2015-05-30T18:17:07.000Z</published>
    <updated>2015-10-11T00:31:05.021Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><ul>
<li><a href="http://www.lintcode.com/en/problem/largest-rectangle-in-histogram/" target="_blank" rel="external">题目链接</a></li>
</ul>
<h1 id="思考">思考</h1><h2 id="方法1:_O(n^2)的遍历做法-">方法1: O(n^2)的遍历做法.</h2><ul>
<li>很简单, 一个个rectangle area计算出来, 然后枚举/排序/找最大.</li>
<li>这里outer loop来抓每一个area的height, 然后分别从它向左/右找第一个比他小的数. 然后计算面积. 在计算的过程中update ans.</li>
<li>这里向左向右的while loop找lhs/rhs可以追述到Algs4的Binary search, Quick Sort的partition. 或者是Maximum subarray的Divide &amp; Conquer的做法.</li>
<li>这里很重要的一点: 还是: 数列问题的index. 这里的终止条件是i = -1 || i = length. 这样的话, 可以统一起来lhs总是比他小的那个位置, rhs总是比他大的那个位置. 从而width = rhs-lhs-1.</li>
</ul>
<h2 id="方法2:_Stack的使用:_O(1)找左右第一个比他小的数">方法2: Stack的使用: O(1)找左右第一个比他小的数</h2><ul>
<li>Stack又一个用法: 一个<strong>严格</strong>单调递增的stack. 它的左边第一个就是就是比它小的第一个数.</li>
<li><p>九章课上说, 可以有2个方法:</p>
<ol>
<li>正着跑一边incStk, 找到他的左边第一个比他小的位置, 然后reverse array, 再跑一遍stack, 找到右边第一个比他小的位置. (这和方法1有什么区别? 有的, 这个是O(n)找到所有点的左右范围.)</li>
<li>也可以是九章答案的做法, 就是for里面一个while, 来维持单调递增性, 若违反了, 则说明找到了右边界, 因为其左侧第一个就是第一个比他小的数的位置.</li>
</ol>
</li>
<li><p>但是: 虽然意思懂了, 但是一做发现很多错误! 我第一次在Lintcode上面写就出现了一个很好的错误: 如果[1,1]的话怎么弄? 应该输出2, 但我得到1! 这是因为我的width计算不对.</p>
<ul>
<li>有个很重要的点: 例如[1], 然后cur = 0. 那么右边界找到了, 接着pop, 于是incStk = []. 那么左边界是多少呢? 我当时直接i-l-1. 其中l是incStk.peek(). 其实这样不对. 也导致了我的area是1. 因为stack为空, 说明height[pop()]的左边界是通到i = 0! 即width = i.</li>
<li>上面的这个错误的原因还有一个! 就是我在while loop判断的时候用的是”&lt;”, 也就是维护的是一个<code>单调不递减</code>stack, 而不是<code>单调递增</code>stack. 这样的后果是, incStk出现了[1,1], 然后cur = 0. 接着pop位于第二个的1. 算出来的不知道是有什么物理意义. 所以正确的做法是while loop的判断用的是<code>&lt;=</code>. 从而保证单调递增, 即左边就是比它小的数.</li>
</ul>
</li>
</ul>
<h2 id="方法3:_Dynamic_programming:_凡是找极值都应该想想动态规划-">方法3: Dynamic programming: 凡是找极值都应该想想动态规划.</h2>]]></content>
    <summary type="html">
    <![CDATA[做完九章Ladder]]>
    
    </summary>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Stack" scheme="http://vlsi1217.github.io/tags/Stack/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Algs-Japan-toc]]></title>
    <link href="http://vlsi1217.github.io/2015/05/26/MOOC/Algorithm_JapanBook/Algs-Japan-toc/"/>
    <id>http://vlsi1217.github.io/2015/05/26/MOOC/Algorithm_JapanBook/Algs-Japan-toc/</id>
    <published>2015-05-26T17:48:07.000Z</published>
    <updated>2015-05-26T18:00:28.073Z</updated>
    <content type="html"><![CDATA[<h1 id="Elementary">Elementary</h1><h2 id="1-_exhaustive_search">1. exhaustive search</h2><h2 id="2-_Greedy">2. Greedy</h2><h2 id="3-_DP_I">3. DP I</h2><h2 id="4-_Data_Structure">4. Data Structure</h2><h2 id="5-_Graph">5. Graph</h2><h2 id="6-_Math_trick">6. Math trick</h2><h2 id="*-_Problems">*. Problems</h2><h1 id="Intermediate">Intermediate</h1><h2 id="1-_Binary_Search">1. Binary Search</h2><h2 id="2-_Tricks_I">2. Tricks I</h2><h2 id="3-_Data_Structure">3. Data Structure</h2><h2 id="4-_DP_II">4. DP II</h2><h2 id="5-_Max_flow/Min_cut">5. Max flow/Min cut</h2><h2 id="6-_jihe">6. jihe</h2><h2 id="*-_Problems-1">*. Problems</h2><h1 id="High">High</h1><h2 id="1-_Math_Problems">1. Math Problems</h2><h2 id="2-_Game_Strategies">2. Game Strategies</h2><h2 id="3-_Graph_Theory">3. Graph Theory</h2><h2 id="4-_Tricks_II">4. Tricks II</h2><h2 id="5-_Clever_search">5. Clever search</h2><h2 id="6-_Divide_and_Conquer">6. Divide and Conquer</h2><h2 id="7-_Elegant_String_Algs">7. Elegant String Algs</h2><h2 id="*-_problems">*. problems</h2>]]></content>
    <summary type="html">
    <![CDATA[Path of learning the book: 挑战程序设计竞赛]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://vlsi1217.github.io/tags/Algorithm/"/>
    
      <category term="OA" scheme="http://vlsi1217.github.io/tags/OA/"/>
    
      <category term="OA" scheme="http://vlsi1217.github.io/categories/OA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Report: Word Break]]></title>
    <link href="http://vlsi1217.github.io/2015/05/25/Leetcode/Report/Report-Word-Break/"/>
    <id>http://vlsi1217.github.io/2015/05/25/Leetcode/Report/Report-Word-Break/</id>
    <published>2015-05-25T23:47:56.000Z</published>
    <updated>2015-05-26T00:37:39.905Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><ul>
<li><a href="http://www.lintcode.com/en/problem/word-break/" target="_blank" rel="external">题目链接</a></li>
</ul>
<h1 id="思考">思考</h1><h2 id="first_trial:_fail">first trial: fail</h2><ul>
<li>这里我还是对DP的状态没搞清楚. 做DP之前, 乃至所有coding之前要想好再动手!</li>
<li>对Substring不熟. 对string不熟. <code>s.substring(a,b+1)</code>表示的是string[a…b]. 所以<code>s.substring(0, s.length()+1)</code>才是返回整个string的.</li>
<li>String的DP表的边界往往是DP[s.length()+1]. 因为<code>DP[0] = true</code>: 表示: 选择string的0个元素也是符合条件的. 然后结果就是返回DP[s.length()]表示选择s的所有元素.</li>
<li>这里的optimally equation搞了很久. 其实公式是知道的, 但是一直不对. 其实就是: DP[i] = DP[j], j &lt; i &amp;&amp; s.substring(j,i+1)在dict内.</li>
<li>代码如下: 第一次写的时候, i,k这样写的话感觉不是很通用. 是在for loop statement的地方写好range, 还是在loop里面+1?  这里因为我的i的范围是1~s.length()<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> wordBreak1st(<span class="keyword">String</span> s, Set&lt;<span class="keyword">String</span>&gt; dict) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">boolean</span>[] F = <span class="keyword">new</span> <span class="built_in">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    F[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; i; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (F[k] == <span class="keyword">true</span> &amp;&amp; dict.contains(s.substring(k, i + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(s.substring(k, i + 1) + "," + k + "+" + i);</span></span><br><span class="line">            F[i] = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (F[k] == <span class="keyword">true</span> &amp;&amp; dict.contains(s.substring(k + <span class="number">1</span>, i + <span class="number">1</span>))) &#123;</span><br><span class="line">          F[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// System.out.println(s.substring(k + 1, i + 1) + "," + k + "+" + i);</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (boolean b : F)</span></span><br><span class="line">    <span class="comment">// System.out.print(b + " ");</span></span><br><span class="line">    <span class="keyword">return</span> F[s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2nd_trial:_TLE">2nd trial: TLE</h2><ul>
<li>模仿Code Ganker的写法, 特别是边界的定义. 因为如果是像第一次那样定义的话, k还要分2种情况. 代码很麻烦, 特别是对于index处理越多越容易乱或者出错</li>
<li>注意这里的i的范围是一般向的0…s.length()-1. 而j的范围是0…i. 注意这个i是包括的. 因为s.substring(k, i+1). 所以k最大应该取到i, 这样substring就是s[i].</li>
<li>这时候的时间复杂度是O(n^2). 不过如同<a href="http://stackoverflow.com/a/4679775/3984911" target="_blank" rel="external">SOF link</a>: substring()是O(n)操作. 所以其实是: O(n^3)的时间复杂度.</li>
<li>就算这样, 还是TLE!</li>
<li>代码如下:<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> wordBreak2nd(<span class="keyword">String</span> s, Set&lt;<span class="keyword">String</span>&gt; dict) &#123;</span><br><span class="line">   <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">boolean</span>[] F = <span class="keyword">new</span> <span class="built_in">boolean</span>[s.length() + <span class="number">1</span>]; <span class="comment">// string DP always leave 0th as no select always</span></span><br><span class="line">                                              <span class="comment">// true, so the DP space is len+1.</span></span><br><span class="line">   F[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123; <span class="comment">// notice the init and end of i for states</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt;= i; ++k) &#123;</span><br><span class="line">       <span class="keyword">if</span> (F[k] == <span class="keyword">true</span> &amp;&amp; dict.contains(s.substring(k, i+<span class="number">1</span>))) &#123;</span><br><span class="line">         F[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> F[s.length()];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4th_trial:_AC">4th trial: AC</h2><ul>
<li>看了九章的参考答案. 发现这时候没有的变成O(n). 那只有prune了. 注意到, F[k]==true的时候, 其实并不用判断所有substring(k, i+1). 因为如果这个substring长于dict内单词的长度就可以不用考虑了. 而且通常来说: word的长度最多25左右. 即i-k+1&lt;=maxlen, 即<code>k&gt;=i-1-maxlen</code>.(注意这里的是i, 不是i+1) 所以可以缩小一点k的取值范围.</li>
<li>代码如下:<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> wordBreak2nd(<span class="keyword">String</span> s, Set&lt;<span class="keyword">String</span>&gt; dict) &#123;</span><br><span class="line">   <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">boolean</span>[] F = <span class="keyword">new</span> <span class="built_in">boolean</span>[s.length() + <span class="number">1</span>]; <span class="comment">// string DP always leave 0th as no select always</span></span><br><span class="line">                                              <span class="comment">// true, so the DP space is len+1.</span></span><br><span class="line">   F[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123; <span class="comment">// notice the init and end of i for states</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt;= i; ++k) &#123;</span><br><span class="line">       <span class="keyword">if</span> (F[k] == <span class="keyword">true</span> &amp;&amp; dict.contains(s.substring(k, i+<span class="number">1</span>))) &#123;</span><br><span class="line">         <span class="comment">// System.out.println(s.substring(k, i) + "," + k + "+" + i);</span></span><br><span class="line">         F[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// for (boolean b : F)</span></span><br><span class="line">   <span class="comment">// System.out.print(b + " ");</span></span><br><span class="line">   <span class="keyword">return</span> F[s.length()];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="总结">总结</h1><ol>
<li>DP问题一定要想清楚state和optimally equation在写代码.</li>
<li>loop的范围, 以及得到state的方式一定要设计好. 例如这里的是F[i+1]还是F[i]就很大差别. 因为这里要表示的是: 取string前i个元素是成立的. 所以substring(k, i+1), 然后F[i+1]. 这样就是i个元素的state成立, 于是接下来就可以F[k] &amp;&amp; substring. 因为这样substring的下确界k正好是kth元素. eg: F[4] &amp;&amp; substring(4,7).<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l i n t c o d e</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="type">F</span>[<span class="number">4</span>] = <span class="literal">true</span>, <span class="built_in">substring</span>(<span class="number">4</span>, <span class="number">7</span>+<span class="number">1</span>) =&gt; <span class="type">F</span>[<span class="number">7</span>+<span class="number">1</span>] = <span class="literal">true</span>. 对于lintcode的例子.</span><br><span class="line"><span class="type">F</span>[<span class="number">7</span>] = <span class="literal">true</span>, <span class="built_in">substring</span>(<span class="number">7</span>, <span class="number">7</span>+<span class="number">1</span>) =&gt; <span class="type">F</span>[<span class="number">7</span>+<span class="number">1</span>] = <span class="literal">true</span>.  对于<span class="type">ProgramCreek</span>的例子.</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[O() != TLE. 同样的O(), 但是实际时间还是会导致TLE]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Report: Triangle Min Path Sum]]></title>
    <link href="http://vlsi1217.github.io/2015/05/24/Leetcode/Report/Report-Triangle/"/>
    <id>http://vlsi1217.github.io/2015/05/24/Leetcode/Report/Report-Triangle/</id>
    <published>2015-05-24T23:39:08.000Z</published>
    <updated>2015-05-24T23:44:35.329Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><h1 id="思路">思路</h1><h1 id="问题">问题</h1><h2 id="first_trial_:_TLE">first trial : TLE</h2><ul>
<li><p>如果使用简单的recursion会出现TLE, 代码如下:</p>
  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @param triangle: a list of lists of integers.</span><br><span class="line">     * @return: An integer, minimum path sum.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> minimumTotal(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="built_in">triangle</span>) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">min</span> = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;Integer.MAX_VALUE&#125;;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">min</span>, <span class="built_in">triangle</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> dfs(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> sum, <span class="built_in">int</span>[] <span class="built_in">min</span>, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="built_in">triangle</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="built_in">triangle</span>.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">min</span>[<span class="number">0</span>] = Math.<span class="built_in">min</span>(<span class="built_in">min</span>[<span class="number">0</span>], sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(x+<span class="number">1</span>, y, sum+<span class="built_in">triangle</span>.<span class="built_in">get</span>(x).<span class="built_in">get</span>(y), <span class="built_in">min</span>, <span class="built_in">triangle</span>);</span><br><span class="line">        dfs(x+<span class="number">1</span>, y+<span class="number">1</span>, sum+<span class="built_in">triangle</span>.<span class="built_in">get</span>(x).<span class="built_in">get</span>(y), <span class="built_in">min</span>, <span class="built_in">triangle</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lintcode里面TLE的页面如下: <img src="http://7xj2zx.com1.z0.glb.clouddn.com/Lintcode_TLE_Triangle.JPG" alt="TLE_lintcode"></li>
<li>有几个要注意的地方:<ol>
<li>因为Lintcode是给了class, 要求写method. 虽然可以有helper method, 例如这里的dfs. 但是因为triangle不是field, 只是一个param, 所以必须要传给helper当param. 不然用不了.</li>
<li>Lintcode 的 test case是看不到全部的… 所以也不能copy放到eclipse里面算了. 但是有个基本常识就是一般不能有超过20层的recursion. 所以尽量不用recursion才行.</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2nd_trial:_pass">2nd trial: pass</h2><ul>
<li>看到这种Divide and Conquer的问题自然想到使用DP解决. 这样可以使用重复计算的部分, 而且避免递归. 注意到: 这是一个找min的值的问题. 自然是DP</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[九章算法的学习DP的经典例子]]>
    
    </summary>
    
      <category term="DC" scheme="http://vlsi1217.github.io/tags/DC/"/>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Report: Jump Game I]]></title>
    <link href="http://vlsi1217.github.io/2015/05/24/Leetcode/Report/Report-Jump-Game-I/"/>
    <id>http://vlsi1217.github.io/2015/05/24/Leetcode/Report/Report-Jump-Game-I/</id>
    <published>2015-05-24T23:26:26.000Z</published>
    <updated>2015-05-24T23:37:32.345Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>学习了经典的DP<ul>
<li>还有<code>local, global最优解DP</code></li>
<li>以及变动边界的loop</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="题目">题目</h1><ul>
<li>题目链接](<a href="http://www.lintcode.com/en/problem/jump-game/" target="_blank" rel="external">http://www.lintcode.com/en/problem/jump-game/</a>)</li>
<li>好的test case: <code>{0,8,2,0,9}</code>,<code>{5, 8, 3, 0, 6, 7, 9, 6, 3, 4, 5, 2, 0, 6, 2, 6, 7, 10, 8, 0}</code></li>
</ul>
<h1 id="思考">思考</h1><h2 id="first_trial:_fail">first trial: fail</h2><ul>
<li>状态: boolean F[i] 表示能否从起点到达position i.</li>
<li>一开始我的optimally equation想错了: 我想的是: F[i] = F[k] &amp;&amp; A[k]&gt;= abs(k-i). 这里的k是0…A.length. 在一开始的test case可以过, 但是<code>{5, 8, 3, 0, 6, 7, 9, 6, 3, 4, 5, 2, 0, 6, 2, 6, 7, 10, 8, 0}</code>就错了. 应该是true, 但我返回false.<ul>
<li>这里有2个错误, 一开始我想的是会不会有先跳到远的, 然后跳回来近的, 再跳到终点. 实际上是不会的, 因为这里的A[i]表示的是从position i, 能跳的<strong>最远距离</strong>, 而不是能跳的距离(像<strong>大富翁</strong>). 所以k不应该loop全部node, 而是小于i的所有node.</li>
<li>更严重的错误是: F[i]表示的是<strong>是否</strong>能从起点到达. 所以只要能到达, 就OK了. 也就是说: 只要true, 就停止loop. 这也是导致我的这个code fail的原因.</li>
</ul>
</li>
</ul>
<h2 id="second_trial:_OK">second trial: OK</h2><ul>
<li>这一次, 我还是DP, 不过改好了optimally equation, 即只要发现F[i]==true就break loop.</li>
<li>但是这时候的时间是O(n**2). 因为要loop每一个node, 每一个node的内循环最坏情况是loop完所有小于i的k. 所以<code>n+n-1+n-2+...+1 = O(n^2)</code>. 而且空间是O(n).</li>
</ul>
<h2 id="third_trial:_Failed">third trial: Failed</h2><ul>
<li>这里还是使用Greedy最好, 因为只要最远距离超过position就行了, 那就看每一步能跳到的最远距离就行了. 实现的时候是使用经典的: <strong>local/global optimal</strong>. 再次复习一下这种使用2个DP表来解决问题的DP方法. 即local DP记录: 以目前node出发能得到的最优解. Global则是记录历史到目前node位置能得到的最优解.</li>
<li>还要复习一下Greedy, 我之前的理解不对:<ul>
<li>错误: 之前想的是, Greedy不就是从位置1跳最远距离, 例如跳到位置5, 然后再从位置5跳最远距离. 觉得这种Greedy太Greedy了. 很有可能, 位置5的A[5]=0. 那就没得跳了.</li>
<li>实际上, Greedy是针对每一个node都考虑一遍Greedy. 即: 1-5, 2-4-7, 3-9-dest.</li>
</ul>
</li>
<li>实现上面, Ganker只用了O(1)的空间. 我则是使用通用的DP表, 记录每一个node的state.</li>
<li>代码<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">jumpLocalGlobalDP</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span>[] local = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    <span class="keyword">int</span>[] global = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init base condition</span></span><br><span class="line">    local[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">    global[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the local/global DP table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i) &#123;</span><br><span class="line">      local[i] = A[i] + i;</span><br><span class="line">      global[i] = Math.max(global[i-<span class="number">1</span>], local[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans</span></span><br><span class="line">    <span class="keyword">if</span> (global[A.length-<span class="number">1</span>] &gt;= A.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Forth_trial:_AC">Forth trial: AC</h2><ul>
<li>刚才的做法是错误的, 例如{0,8,2,0,9}.</li>
<li>仔细研究一下Ganker的写法, 他并不是简单的loop, 而是会改变boundary的loop. 这个很有意思. 在使用一个queue实现的BFS模版里面, 有个很重要的点就是queue.size()不能作为boundary, 要int size = queue.size(). 因为queue会在loop里面改变大小. 而这里之所以要使用变动的boundary是因为, 如果当前node只考虑能打到的情况. 例如这个例子里面, node 1是达不到的.</li>
<li>所以很重要的一点是loop的范围应该是:<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int i = 1; i &lt;= global[i-1] &amp;&amp; i &lt; A.length; ++i)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[经典的DP, Greedy问题]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Greedy" scheme="http://vlsi1217.github.io/tags/Greedy/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit7-9chap-Graph]]></title>
    <link href="http://vlsi1217.github.io/2015/05/23/Leetcode/9chap/Unit7-9chap-Graph/"/>
    <id>http://vlsi1217.github.io/2015/05/23/Leetcode/9chap/Unit7-9chap-Graph/</id>
    <published>2015-05-23T20:17:54.000Z</published>
    <updated>2015-05-23T20:24:15.731Z</updated>
    <content type="html"></content>
    <summary type="html">
    <![CDATA[田老师第二课: 学习总结Graph相关的面试题目]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit6-9chap-List]]></title>
    <link href="http://vlsi1217.github.io/2015/05/23/Leetcode/9chap/Unit6-9chap-List/"/>
    <id>http://vlsi1217.github.io/2015/05/23/Leetcode/9chap/Unit6-9chap-List/</id>
    <published>2015-05-23T20:17:25.000Z</published>
    <updated>2015-05-23T20:24:08.815Z</updated>
    <content type="html"></content>
    <summary type="html">
    <![CDATA[田老师的第一课: list题目总结]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://vlsi1217.github.io/tags/List/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit 5 NineChap : Dynamic programming - part I]]></title>
    <link href="http://vlsi1217.github.io/2015/05/22/Leetcode/9chap/Unit5-9chap-DP2/"/>
    <id>http://vlsi1217.github.io/2015/05/22/Leetcode/9chap/Unit5-9chap-DP2/</id>
    <published>2015-05-22T17:33:53.000Z</published>
    <updated>2015-05-23T20:23:49.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>今天继续讲Dynamic Programming.<ul>
<li>后2个常见的DP类型题: Two Sequence DP和Backpack.</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[段誉最后一课: 总结DP问题的后2个常见题型]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CircularQueue]]></title>
    <link href="http://vlsi1217.github.io/2015/05/22/OS/CircularQueue/"/>
    <id>http://vlsi1217.github.io/2015/05/22/OS/CircularQueue/</id>
    <published>2015-05-22T17:28:57.000Z</published>
    <updated>2015-05-26T21:55:07.586Z</updated>
    <content type="html"><![CDATA[<h2 id="Circular_Queue的作用">Circular Queue的作用</h2><ul>
<li>在SRAM里面相当于是无限大的buffer. 实现基本都是下图所示:<br><img src="http://7xj2zx.com1.z0.glb.clouddn.com/cmycode_CB.PNG" alt="ringBuffer">. 其中enqueue在Head, dequeue在tail. 且Head指向下一个插入的位置, Tail指向下一个可以读取的位置. 这样每次进来, 只要判断是否wrap, full. 然后就可以读写了.</li>
<li>在一般来说是作为asynch thread communication. 见<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.201501/labs/lab05-ringbuf/ringbuf.pdf" target="_blank" rel="external">CS105: Harvey Mudd</a></li>
<li>实现方式: <a href="https://github.com/angrave/SystemProgramming/wiki/Synchronization,-Part-8:-Ring-Buffer-Example" target="_blank" rel="external">github-Synchronization-CircularQueue</a>.</li>
</ul>
<h2 id="Circular_Queue的区别">Circular Queue的区别</h2><ul>
<li><p>wiki已经写了circular queue的几种实现方式, 区别在于判断empty/full的方式:</p>
<ol>
<li><p>head/tail+1 empty slot</p>
<ul>
<li>这个实现在: Ring Buffer_Anders Kaloer</li>
<li>Scott的Firmware里面的也是这样做的.</li>
</ul>
</li>
<li><p>head/tail+count</p>
<ul>
<li>一般都是用这个写, 因为简单, 而且semaphore其实就使这个count. 表示的是: 当前queue里面保存的item数量.</li>
<li>我参考的Harshkn的写法. 改了一点. 主要是count在满了之后就不动了. 然后在push/pop里面加入了判断error的代码, 来自于kqchen.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="实现代码">实现代码</h2><h3 id="1-_使用Count">1. 使用Count</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * https://gist.github.com/harshkn/909546</span><br><span class="line"> * C Implementation of simple circular buffer, Functionality provided are add to queue, read latest</span><br><span class="line"> *</span><br><span class="line"> * Implementation: head, tail, and count. The major different between AndersKaloer/Harshkn is the way to detect full/empty.</span><br><span class="line"> * The former trade with an empty slot, the latter use additional int-&gt;count. I review this because this is easier and Scott uses it too.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> circular_buffer &#123;</span><br><span class="line">	void *buffer;     <span class="comment">// data buffer</span></span><br><span class="line">	void *buffer_end; <span class="comment">// end of data buffer</span></span><br><span class="line">	size_t capacity;  <span class="comment">// maximum number of items in the buffer</span></span><br><span class="line">	size_t count;     <span class="comment">// number of items in the buffer</span></span><br><span class="line">	size_t sz;        <span class="comment">// size of each item in the buffer</span></span><br><span class="line">	void *head;       <span class="comment">// pointer to head</span></span><br><span class="line">	void *tail;       <span class="comment">// pointer to tail</span></span><br><span class="line">&#125; circular_buffer;</span><br><span class="line"></span><br><span class="line">void cb_init(circular_buffer *cb, size_t capacity, size_t sz) &#123;</span><br><span class="line">	cb-&gt;buffer = malloc(capacity * sz);</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;buffer == NULL) &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">	&#125;</span><br><span class="line">	cb-&gt;buffer_end = (<span class="keyword">char</span> *) cb-&gt;buffer + capacity * sz;</span><br><span class="line">	cb-&gt;capacity = capacity;</span><br><span class="line">	cb-&gt;count = <span class="number">0</span>;</span><br><span class="line">	cb-&gt;sz = sz;</span><br><span class="line">	cb-&gt;head = cb-&gt;buffer;</span><br><span class="line">	cb-&gt;tail = cb-&gt;buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cb_free(circular_buffer *cb) &#123;</span><br><span class="line">	free(cb-&gt;buffer);</span><br><span class="line">	<span class="comment">// clear out other fields too, just to be safe</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cb_push_back(circular_buffer *cb, <span class="keyword">const</span> void *item) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;count == cb-&gt;capacity) &#123;</span><br><span class="line">		printf(<span class="string">"%s, %d: cb push back error. \n"</span>, __FILE__, __LINE__);</span><br><span class="line"><span class="comment">//		return;</span></span><br><span class="line">	&#125;</span><br><span class="line">	memcpy(cb-&gt;head, item, cb-&gt;sz);</span><br><span class="line">	printf(<span class="string">"push data = %d\n"</span>, *(<span class="keyword">char</span> *) cb-&gt;head);</span><br><span class="line">	cb-&gt;head = (<span class="keyword">char</span>*) cb-&gt;head + cb-&gt;sz;</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;head == cb-&gt;buffer_end)</span><br><span class="line">		cb-&gt;head = cb-&gt;buffer;</span><br><span class="line">	cb-&gt;count = cb-&gt;count == cb-&gt;capacity ? cb-&gt;count : cb-&gt;count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cb_pop_front(circular_buffer *cb, void *item) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">		printf(<span class="string">"%s, %d: cb_pop_front: empty cb.\n"</span>, __FILE__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	memcpy(item, cb-&gt;tail, cb-&gt;sz);</span><br><span class="line">	printf(<span class="string">"pop data = %d\n"</span>, *(<span class="keyword">char</span> *) cb-&gt;tail);</span><br><span class="line">	cb-&gt;tail = (<span class="keyword">char</span>*) cb-&gt;tail + cb-&gt;sz;</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;tail == cb-&gt;buffer_end)</span><br><span class="line">		cb-&gt;tail = cb-&gt;buffer;</span><br><span class="line">	cb-&gt;count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cb_empty(circular_buffer *cb) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cb-&gt;count == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cb_full(circular_buffer *cb) &#123;</span><br><span class="line">	<span class="keyword">return</span> cb-&gt;count == cb-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printbuf(circular_buffer *cb) &#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; cb-&gt;capacity; ++i)</span><br><span class="line">		printf(<span class="string">"%d "</span>, *(<span class="keyword">char</span> *) (cb-&gt;buffer + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * https://github.com/kqchen/workspace/blob/21ab1c18dbf6c674437b0c89bb313ddbfc2de85c/hello/circular.c</span><br><span class="line"> */</span></span><br><span class="line">void cb_print(circular_buffer *cb) &#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = cb-&gt;count;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">			printf(<span class="string">"%s, %d: cb is empty now.\n"</span>, __FILE__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"cb-&gt;tail=0x%x, cb-&gt;head=0x%x, cnt = %d\n"</span>, cb-&gt;tail, cb-&gt;head,</span><br><span class="line">				cnt);</span><br><span class="line">		cnt--;</span><br><span class="line">	&#125; <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * testing the ring buffer</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">	circular_buffer tony; <span class="comment">// a holder</span></span><br><span class="line">	cb_init(&amp;tony, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">		cb_push_back(&amp;tony, &amp;i);</span><br><span class="line"><span class="comment">//		printf("%d with count: %d, data = %d\n", cb_full(&amp;tony), tony.count, i);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(<span class="string">"\nafter filling ---\n"</span>);</span><br><span class="line">	cb_print(&amp;tony);</span><br><span class="line"><span class="comment">//	printf("after filling ---\n");</span></span><br><span class="line"><span class="comment">//	printbuf(&amp;tony);</span></span><br><span class="line">	<span class="keyword">char</span> result;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">		cb_pop_front(&amp;tony, &amp;result);</span><br><span class="line"><span class="comment">//		printf("%d with count: %d, result = %d\n", cb_empty(&amp;tony), tony.count, result);</span></span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">"\nafter pop ---\n"</span>);</span><br><span class="line">	cb_print(&amp;tony);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[整理一下Scott的Circular Queue的设计]]>
    
    </summary>
    
      <category term="OS" scheme="http://vlsi1217.github.io/categories/OS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Interleaving String 解题报告]]></title>
    <link href="http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-Distinct%20Subsequences/"/>
    <id>http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-Distinct Subsequences/</id>
    <published>2015-05-20T18:17:07.000Z</published>
    <updated>2015-06-06T23:38:55.202Z</updated>
    <content type="html"><![CDATA[<h1 id="Report:_Interleaving_String">Report: Interleaving String</h1><p>标签（空格分隔）： Lintcode DP Ladder</p>
<hr>
<h1 id="题目">题目</h1><ul>
<li><a href="http://www.lintcode.com/en/problem/interleaving-string/" target="_blank" rel="external">题目链接</a></li>
</ul>
<h1 id="思考">思考</h1><h2 id="first_trial:_fail">first trial: fail</h2><ul>
<li>F[i][j]表示是否可以用S1, S2的前i,j个字符表示S3的前i+j个字符. 既然是M x N的DP, 自然要先init 第一行和第一列.</li>
<li>然后就是optimally equation. 就是每次看S3的i+j-1个字符是否等于S1的i-1或者S2的j-1. 如果是, 就沿用F[i-1][j]或F[i][j-1].</li>
<li>但是这样fail在第15/18个test case:<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sdfjas;dfjoisdufzjkndfasdkfja;sdfa;dfa;dfaskdjhfasdhjdfakhdgfkajdfasdjfgajksdfgaksdhfasdkbfjkdsfbajksdfhakjsdfbajkdfbakdjsfgaksdhgfjkdsghfkdsfgadsjfgkajsdgfkjasdfh"</span>, <span class="string">"dfnakdjnfjkzghdufguweygfasjkdfgb2gf8asf7tgbgasjkdfgasodf7asdgfajksdfguayfgaogfsdkagfsdhfajksdvfbgkadsghfakdsfgasduyfgajsdkfgajkdghfaksdgfuyadgfasjkdvfjsdkvfakfgauyksgfajkefgjkdasgfdjksfgadjkghfajksdfgaskdjfgasjkdgfuyaegfasdjkfgajkdfygadjskfgjkadfg"</span>, <span class="string">"sdfjas;dfjoisdfnakdjnfjkzghdufguwdufzjkeygfasjkdfgb2gf8asf7ndtgbgasjkdfgasodf7asdfgfajkasdksdfguayfgaogfsdkagfsfjadhfajksdvfbgkadsghfa;sdkdsfgasduyfgajsdkfgafajkdghfaksdgfuyadgfas;dfjkdvfjsdkvfakfgauyksa;dgfajkefgjkdasgfdjksffaskdjhfasdhjdfakhdgadjkghfajgfkajdfksdfgaskdjfgasjkdgfuasdjfgajksdfgaksdhfasdkbfjkdsfbajksdfyaegfasdjkfgajkdfygadjskfgjkadfghakjsdfbajkdfbakdjsfgaksdhgfjkdsghfkdsfgadsjfgkajsdgfkjasdfh"</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>应该return false, 但我return true.<br>找了好久, 终于发现问题了: 我的递推方程是:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (s3.charAt(i + j - 1) == s1.charAt(i - 1)) &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = F[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>];</span><br><span class="line">&#125; else if (s3.charAt(i + j - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = F[<span class="link_label">i</span>][<span class="link_reference">j - 1</span>];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里: 如果s1.charAt(i - 1)和s3.charAt(i + j - 1)和s2.charAt(j - 1)相等的话, F[i][j]是给else if覆盖了. 所以有时候对有时候错. 所以是我的optimally equation写错了. 这里是or的关系.</p>
<h2 id="2nd_trial:_AC">2nd trial: AC</h2><ul>
<li>这次解决了这个bug. 使用OR来得到F[i][j].</li>
</ul>
<h2 id="3rd_trial:_fail">3rd trial: fail</h2><ul>
<li>虽然刚才那样做是可以AC, 但是空间复杂度太大! 因为这个只和上一层跟左一列有关系. 所以可以用1d的rolling array来做. 那为什么这里和distinct subsequences的1d不同, 是自左向右循环呢? 分析如下:</li>
<li>update的时候要看是否使用更新前还是更新后的上一层的信息.<ul>
<li>例如distinct subsequences就是使用更新前的上一层信息, 所以内循环是<strong>自后往前</strong>.</li>
<li>而像Interleaving string的1d rolling array就是自前向后.</li>
<li>这2个有什么区别呢: 区别在于optimally equation, 看到底需要上一层的哪个数, 如果是上一层的左边, 那么就不能覆盖的循环, 所以要自后向前. 而且若是同时需要上一层左侧和这一层左侧的话就不能用1d滚动数组了, 用mod rolling.</li>
<li>总结见下图: <img src="http://7xj2zx.com1.z0.glb.clouddn.com/9chap_rollingDP_interleaveDistinctSubseq.PNG" alt="9chap_rollingDP"></li>
</ul>
</li>
<li>Ganer就是这样写的. 但是我一开始先是像<a href="http://blog.csdn.net/linhuanmars/article/details/23589057" target="_blank" rel="external">distinct substring</a>那样写: 即内循环是<strong>从后向前</strong>来update State. 结果是错的.<ul>
<li>所以这里有个重要事情. 什么时候是自前向后, 什么时候自后向前. 这里并不是说Top-down, Bottom-up. 而是说1d rolling array里面是使用更新前还是更新后的值.<blockquote>
<p>每次迭代我们只保存了上一行的信息。接下来从前往后还是从后往前就取决于我们要用的是更新前还是更新后的信息，如果从前往后，我们会使用更新后的信息</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="4th_trial_:_AC">4th trial : AC</h2><ul>
<li>这题和distinct substring 的 rolling array的内层循环不同的是: 这里是从前往后.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Interleaving String 解题报告]]></title>
    <link href="http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-Interleaving%20String/"/>
    <id>http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-Interleaving String/</id>
    <published>2015-05-20T18:17:07.000Z</published>
    <updated>2015-06-06T23:38:55.202Z</updated>
    <content type="html"><![CDATA[<h1 id="Report:_Interleaving_String">Report: Interleaving String</h1><p>标签（空格分隔）： Lintcode DP Ladder</p>
<hr>
<h1 id="题目">题目</h1><ul>
<li><a href="http://www.lintcode.com/en/problem/interleaving-string/" target="_blank" rel="external">题目链接</a></li>
</ul>
<h1 id="思考">思考</h1><h2 id="first_trial:_fail">first trial: fail</h2><ul>
<li>F[i][j]表示是否可以用S1, S2的前i,j个字符表示S3的前i+j个字符. 既然是M x N的DP, 自然要先init 第一行和第一列.</li>
<li>然后就是optimally equation. 就是每次看S3的i+j-1个字符是否等于S1的i-1或者S2的j-1. 如果是, 就沿用F[i-1][j]或F[i][j-1].</li>
<li>但是这样fail在第15/18个test case:<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sdfjas;dfjoisdufzjkndfasdkfja;sdfa;dfa;dfaskdjhfasdhjdfakhdgfkajdfasdjfgajksdfgaksdhfasdkbfjkdsfbajksdfhakjsdfbajkdfbakdjsfgaksdhgfjkdsghfkdsfgadsjfgkajsdgfkjasdfh"</span>, <span class="string">"dfnakdjnfjkzghdufguweygfasjkdfgb2gf8asf7tgbgasjkdfgasodf7asdgfajksdfguayfgaogfsdkagfsdhfajksdvfbgkadsghfakdsfgasduyfgajsdkfgajkdghfaksdgfuyadgfasjkdvfjsdkvfakfgauyksgfajkefgjkdasgfdjksfgadjkghfajksdfgaskdjfgasjkdgfuyaegfasdjkfgajkdfygadjskfgjkadfg"</span>, <span class="string">"sdfjas;dfjoisdfnakdjnfjkzghdufguwdufzjkeygfasjkdfgb2gf8asf7ndtgbgasjkdfgasodf7asdfgfajkasdksdfguayfgaogfsdkagfsfjadhfajksdvfbgkadsghfa;sdkdsfgasduyfgajsdkfgafajkdghfaksdgfuyadgfas;dfjkdvfjsdkvfakfgauyksa;dgfajkefgjkdasgfdjksffaskdjhfasdhjdfakhdgadjkghfajgfkajdfksdfgaskdjfgasjkdgfuasdjfgajksdfgaksdhfasdkbfjkdsfbajksdfyaegfasdjkfgajkdfygadjskfgjkadfghakjsdfbajkdfbakdjsfgaksdhgfjkdsghfkdsfgadsjfgkajsdgfkjasdfh"</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>应该return false, 但我return true.<br>找了好久, 终于发现问题了: 我的递推方程是:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (s3.charAt(i + j - 1) == s1.charAt(i - 1)) &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = F[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>];</span><br><span class="line">&#125; else if (s3.charAt(i + j - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = F[<span class="link_label">i</span>][<span class="link_reference">j - 1</span>];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里: 如果s1.charAt(i - 1)和s3.charAt(i + j - 1)和s2.charAt(j - 1)相等的话, F[i][j]是给else if覆盖了. 所以有时候对有时候错. 所以是我的optimally equation写错了. 这里是or的关系.</p>
<h2 id="2nd_trial:_AC">2nd trial: AC</h2><ul>
<li>这次解决了这个bug. 使用OR来得到F[i][j].</li>
</ul>
<h2 id="3rd_trial:_fail">3rd trial: fail</h2><ul>
<li>虽然刚才那样做是可以AC, 但是空间复杂度太大! 因为这个只和上一层跟左一列有关系. 所以可以用1d的rolling array来做. 那为什么这里和distinct subsequences的1d不同, 是自左向右循环呢? 分析如下:</li>
<li>update的时候要看是否使用更新前还是更新后的上一层的信息.<ul>
<li>例如distinct subsequences就是使用更新前的上一层信息, 所以内循环是<strong>自后往前</strong>.</li>
<li>而像Interleaving string的1d rolling array就是自前向后.</li>
<li>这2个有什么区别呢: 区别在于optimally equation, 看到底需要上一层的哪个数, 如果是上一层的左边, 那么就不能覆盖的循环, 所以要自后向前. 而且若是同时需要上一层左侧和这一层左侧的话就不能用1d滚动数组了, 用mod rolling.</li>
<li>总结见下图: <img src="http://7xj2zx.com1.z0.glb.clouddn.com/9chap_rollingDP_interleaveDistinctSubseq.PNG" alt="9chap_rollingDP"></li>
</ul>
</li>
<li>Ganer就是这样写的. 但是我一开始先是像<a href="http://blog.csdn.net/linhuanmars/article/details/23589057" target="_blank" rel="external">distinct substring</a>那样写: 即内循环是<strong>从后向前</strong>来update State. 结果是错的.<ul>
<li>所以这里有个重要事情. 什么时候是自前向后, 什么时候自后向前. 这里并不是说Top-down, Bottom-up. 而是说1d rolling array里面是使用更新前还是更新后的值.<blockquote>
<p>每次迭代我们只保存了上一行的信息。接下来从前往后还是从后往前就取决于我们要用的是更新前还是更新后的信息，如果从前往后，我们会使用更新后的信息</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="4th_trial_:_AC">4th trial : AC</h2><ul>
<li>这题和distinct substring 的 rolling array的内层循环不同的是: 这里是从前往后.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Serialization 解题报告]]></title>
    <link href="http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-BinaryTreeSerialization/"/>
    <id>http://vlsi1217.github.io/2015/05/20/Leetcode/Report/Report-BinaryTreeSerialization/</id>
    <published>2015-05-20T18:17:07.000Z</published>
    <updated>2015-06-06T23:38:20.573Z</updated>
    <content type="html"><![CDATA[<p>标签（空格分隔）： lintcode BFS BinaryTree</p>
<hr>
<h2 id="题目">题目</h2><ul>
<li><a href="http://www.lintcode.com/en/problem/binary-tree-serialization/" target="_blank" rel="external">link点我</a></li>
<li>Example<br>  An example of testdata: Binary tree {3,9,20,#,#,15,7}, denote the following structure, Our data serialization use bfs traversal:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#20351;&#29992;code block&#21487;&#20197;&#20445;&#30041;&#26684;&#24335;&#10;  3&#10; / \&#10;9  20&#10;  /  \&#10; 15   7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分析">分析</h2><h3 id="Serialize">Serialize</h3><ul>
<li>注意这个是Lintcode的Serialize, 和Leetcode的区别在于他使用的是BFS. 而后者则是使用的pre-order DFS.</li>
<li>null object 和 null的区别.</li>
<li>flag的设计: 要有初始值, 在进入循环的时候update, 对于每一个节点再次update. 那么当这一层结束后就是有效的flag.</li>
</ul>
<h3 id="De-serialize">De-serialize</h3><ul>
<li>还是使用BFS解决. 和Pre-order的de-serialize一样, 和各自的Serialize有一个一一对应的关系.</li>
<li>第一次写的时候出现idx超出array size的问题. 这是为什么呢? 因为我在判断token[idx]的时候居然判断了4次. 因为每一次判断都要idx++. 然后我把4个if并成2个if…else就OK了.</li>
<li>注意这个时候的while loop判断不是parents queue是否为空, 而是判断token[] array走完没有. 我一开始这里搞错了, 居然去判断string走完没有. 注意string就是char Array. 例如{3, 9, 20, #, #, 15, 7}, 这个string的length是21. 而token[]则是7.</li>
<li>还有注意这里update parents queue的时候要注意. 这里的做法是对于”#”, 则不加入null到queue. 不然queue的size()就不对了. 因为这里不用traverse null node.</li>
</ul>
<h2 id="code">code</h2><h3 id="1-_Serialize_Binary_Tree_:_BFS遍历">1. Serialize Binary Tree : BFS遍历</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">String <span class="title">serializeBFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; <span class="keyword">parents</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">parents</span>.offer(root);</span><br><span class="line">    <span class="keyword">boolean</span> end = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">parents</span>.isEmpty() &amp;&amp; !end) &#123;</span><br><span class="line">        end = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="keyword">parents</span>.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode head = <span class="keyword">parents</span>.poll();</span><br><span class="line">            <span class="comment">// update result</span></span><br><span class="line">            String thisnode = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                thisnode = <span class="string">"#"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                thisnode = head.value + <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans + thisnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = ans + <span class="string">", "</span> + thisnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update queue</span></span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!head.isLeaf())</span><br><span class="line">                    end = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">parents</span>.offer(head.left);</span><br><span class="line">                <span class="keyword">parents</span>.offer(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>De-serialize binary tree<br><del>还是直接link github代码好了.</del><br>试了几个方法. 最后还是觉得使用gist-it方便. 但是前提是代码不能有中文. 否则python解析不了.</li>
</ol>
<script src="http://gist-it.appspot.com/https://github.com/vlsi1217/leetlint/blob/master/nineChap3_BST/ValidateBST.java">
</script>




]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="BFS" scheme="http://vlsi1217.github.io/tags/BFS/"/>
    
      <category term="Ladder" scheme="http://vlsi1217.github.io/tags/Ladder/"/>
    
      <category term="Lintcode" scheme="http://vlsi1217.github.io/tags/Lintcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit 4 NineChap : Dynamic programming - part I]]></title>
    <link href="http://vlsi1217.github.io/2015/05/13/Leetcode/9chap/Unit4_9chap-DP1/"/>
    <id>http://vlsi1217.github.io/2015/05/13/Leetcode/9chap/Unit4_9chap-DP1/</id>
    <published>2015-05-14T03:17:16.000Z</published>
    <updated>2015-05-24T23:45:24.083Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>今天开始讲Dynamic Programming.<ul>
<li>先讲的前2个常见的DP类型题: Matrix DP和Sequence DP.</li>
<li>下一节课再讲后2个DP类型题: 2 Sequencee DP和Backpack.</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="DP的实现方式:">DP的实现方式:</h2><ol>
<li>top-down的recursion: memorization search</li>
<li>bottom-up的iteration或者recursion.</li>
</ol>
<h2 id="如何想到使用DP">如何想到使用DP</h2><ul>
<li>虽然和recursion都是使用了子问题解决大问题. 不过动归是一种算法思想, 而递归则如同Algs4书本所说: 是一种organize代码的方式.</li>
<li>我感觉段老师这里所说的动归是指严格的动归, 他将memorization search作为广义的动归, 到底还是search.</li>
<li>如何想到使用动归<ul>
<li>满足其中一个条件:<ol>
<li>求极值</li>
<li>判断是否存在</li>
<li>Count(*)</li>
</ol>
</li>
<li>can not sort/swap. 参考LCS(subsequence vs substring)</li>
</ul>
</li>
</ul>
<h2 id="动归4要素">动归4要素</h2><ol>
<li>状态 : 关键的关键. 这个靠经验(参见: <a href="http://blog.csdn.net/liuqiyao_01/article/details/8765812" target="_blank" rel="external">100个动规方程</a>) 相当于几何题目的辅助线. 往往不是一次成功, 要反复的实验. 经典的例子是: LIS.</li>
<li>递推式 : 表述state之间的联系: 如何使用小state来算大state. 这里的大小是段老师定义的. 例如unique path, 小state就是距离起点近的, 大state就是举例起点近, 或者说举例终点近的.</li>
<li>初始条件 : 最极限的小状态. 例如2D DP表就是初始化第一行/第一列.</li>
<li>答案 : 最大的状态.</li>
</ol>
<h2 id="面试最常见的4种类型">面试最常见的4种类型</h2><ol>
<li>Matrix DP(10%)</li>
<li>Sequence (40%)</li>
<li>2 Sequence (40%) —- 全都可以用rolling DP!</li>
<li>Backpack (10%)  —- 可以参考<em>背包九讲2.0</em></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="DP" scheme="http://vlsi1217.github.io/tags/DP/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit 3 NineChap : Binary Tree-Divide & Conquer]]></title>
    <link href="http://vlsi1217.github.io/2015/05/09/Leetcode/9chap/Unit3_9chap-BST-DC/"/>
    <id>http://vlsi1217.github.io/2015/05/09/Leetcode/9chap/Unit3_9chap-BST-DC/</id>
    <published>2015-05-10T03:17:16.000Z</published>
    <updated>2015-05-20T22:13:42.122Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree的2个重点:_DFS和BFS-">Binary Tree的2个重点: DFS和BFS.</h2><h3 id="Traverse">Traverse</h3><blockquote>
<p>必须会iteration. 可以先背下来.</p>
<ul>
<li>Pre</li>
<li>in -&gt; Iterator题目</li>
<li>Post</li>
</ul>
</blockquote>
<h2 id="Divide_and_Conquer">Divide and Conquer</h2><blockquote>
<p>Binary Tree里面的DC和Traverse都是recursion, 本质的区别是D&amp;C的recursion有return, 而Traverse里面的recursion仅仅是用来走Tree, 并不需要return.</p>
</blockquote>
<h3 id="p1-_Binary_Tree_Maximum_Path_Sum">p1. Binary Tree Maximum Path Sum</h3><ul>
<li>3721 先用D&amp;C.</li>
</ul>
<h3 id="p2-_LCA_I/II-_(区别是有没有parent_pointer)">p2. LCA I/II. (区别是有没有parent pointer)</h3>]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="BinaryTree" scheme="http://vlsi1217.github.io/tags/BinaryTree/"/>
    
      <category term="DC" scheme="http://vlsi1217.github.io/tags/DC/"/>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit 2 NineChap: Binary Search]]></title>
    <link href="http://vlsi1217.github.io/2015/05/06/Leetcode/9chap/Unit2_9chap-BinSearch/"/>
    <id>http://vlsi1217.github.io/2015/05/06/Leetcode/9chap/Unit2_9chap-BinSearch/</id>
    <published>2015-05-07T03:17:16.000Z</published>
    <updated>2015-05-20T22:13:35.527Z</updated>
    <content type="html"><![CDATA[<h2 id="2分法模版">2分法模版</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (start + <span class="number">1</span> &lt; <span class="keyword">end</span>) &#123;</span><br><span class="line">    mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[mid] == <span class="type">target</span>) &#123;</span><br><span class="line">        <span class="keyword">end</span> = mid;  // key</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; <span class="type">target</span>) &#123;</span><br><span class="line">        start = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; <span class="type">target</span>) &#123;</span><br><span class="line">        <span class="keyword">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[start] &gt;= <span class="type">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[<span class="keyword">end</span>] &gt;= <span class="type">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">end</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while退出条件: lo+1&lt;hi</li>
<li>中间处理通用: 都是lo=mid, hi=mid. 不用mid+1/mid-1.</li>
<li>while循环结束后, 只要处理2个数就可以了: start和end. 可以很容易分析.<ul>
<li>这里的start/end的意义是什么呢? 并不一定是target的范围就已经确定了, 例如有dup的时候, 就要看你是求first, any, 还是last了.</li>
<li>或者说target不再A[]里面的情况呢? 那么target &lt; A[lo] 或者 A[hi] &lt; target.</li>
</ul>
</li>
</ul>
<h3 id="从复杂度-&gt;算法">从复杂度-&gt;算法</h3><ul>
<li>一般的复杂度有O(n), 比他好的就是O(lgn). 那就只有二分了. 所以看到这种复杂度要求的题目, 就是用二分模版.</li>
</ul>
<h3 id="p1-_search_insert_position">p1. search insert position</h3><ul>
<li>其实根据题意了解到, 就是找first position i, that A[i] &gt;= target. 所以对于这种sorted array的search first/last position就是用二分法.</li>
<li>模版是要灵活运用的, 只是说这样写不太容易出错. 但是也要在适当范围内根据问题来做. 譬如insert的target不再A[]内会怎么样呢? 实际还是只要根据lo/hi这2个数分析就好, 但是这里学到了有了range, 有了lo/hi, 并<strong>不一定</strong>就是分3段: 左中右. 这里的分法有意思. <code>&lt;= low, &lt;= hi, 和大于hi.</code></li>
</ul>
<h2 id="Sorted_Array_问题">Sorted Array 问题</h2><h3 id="重要的2题:_Search_in_rotated_sorted_array">重要的2题: Search in rotated sorted array</h3><ul>
<li>binary search<ul>
<li>重要做题概念: 做题先画图, 容易直观分析.</li>
</ul>
<ul>
<li>如果有duplicate, 就没得2分. 因为lo=mid=hi = 1的话, 所以2分无意义.</li>
</ul>
</li>
<li>不用二分做<ul>
<li>find minimum in rotated sorted array. 也是2分.</li>
<li>recover rotatted sorted array.</li>
<li>然后用min来search, 或者recover在search.</li>
</ul>
</li>
</ul>
<h4 id="p1-_Find_minimum_in_Rotated_sorted_array_I/II">p1. Find minimum in Rotated sorted array I/II</h4><h3 id="重要的2题:_Median_of_two_sorted_arrays">重要的2题: Median of two sorted arrays</h3><ul>
<li>这题的算法思想很重要. 能提升自己的能力.</li>
<li>先做: find kth int of two sorted arrays<ul>
<li>其实就等于做出来median这题了.</li>
</ul>
</li>
<li>注意 k-k/2!=k/2. 因为有奇数偶数的情况. 所以统一用k-k/2.</li>
</ul>
<h4 id="kth_of_two_sorted_arrays">kth of two sorted arrays</h4><h2 id="其他简单">其他简单</h2><ul>
<li>merge sorted array/list.<ul>
<li>小技巧: 从末尾开始插入.<br>+</li>
</ul>
</li>
<li>三步反转法</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unit 1 NineChap: 学习/做题思路]]></title>
    <link href="http://vlsi1217.github.io/2015/05/06/Leetcode/9chap/Unit1_9chap-Perm-Comb/"/>
    <id>http://vlsi1217.github.io/2015/05/06/Leetcode/9chap/Unit1_9chap-Perm-Comb/</id>
    <published>2015-05-07T03:17:16.000Z</published>
    <updated>2015-05-20T22:13:10.807Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>这节课我miss了, 所以只是放上对PPT的理解.<ul>
<li>参考的blog是Shuatiblog.com: <a href="http://www.shuatiblog.com/blog/2014/06/12/NineChap-Permutation/" target="_blank" rel="external">link</a></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="strStr说开去">strStr说开去</h2><ul>
<li>先看到这种substring match的问题就想到是不是有现成的算法啊: 有啊:<ul>
<li>KMP -&gt; O(n)</li>
<li>RB hash</li>
<li>BM 首尾搜索</li>
</ul>
</li>
<li>不过这里是很简单的情况, 最好先写个简单的看出我基本功的可以用的code<ul>
<li>为了不失一般性, 先判断base case. 即太短, sub过长, etc.</li>
<li>然后就可以假定我们的needle是远小于haystack的长度. 然后就是Ganker在substring concatenation那种, 在Haystack里面traverse所有长度为needle.length()的substring, 然后另一个指针对比needle和substring.</li>
</ul>
</li>
</ul>
<h2 id="NP搜索模版:_从Permutation说开去">NP搜索模版: 从Permutation说开去</h2><blockquote>
<ul>
<li>code monkey说: “Permutation problem provides you a list of items, your task is to build, validate and return a somewhat combination of these items. The template is to sort the input first, and add <strong>qualified</strong> item 1 by 1”<ul>
<li>一般这个helper method (或者叫dfs), 都有个控制进入下一步的控制方式, 例如Subset的helper用pos, Permutation用boolean[] used, 等等.</li>
<li>先写一下这个模版:</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; Search(<span class="built_in">int</span>[] A) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    dfs(A, <span class="keyword">new</span> boolean[A.length()], <span class="keyword">new</span> <span class="built_in">List</span>&lt;Integer&gt;(), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="literal">static</span> <span class="keyword">void</span> dfs(<span class="built_in">int</span>[] A, boolean[] used, <span class="built_in">List</span>&lt;Integer&gt; path, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt;res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length() == A.length()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; A.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !used[i-<span class="number">1</span>] &amp;&amp; A[i]==A[i-<span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (used[i])  <span class="keyword">continue</span>;</span><br><span class="line">        path.add(A[i]);</span><br><span class="line">        dfs(A, used, path, res);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="keyword">false</span>;  <span class="comment">// 记得recursion一定要恢复现场. 即call stack回退之后的状态要和进入之前一样. 可以看看Ganker的解释.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subset">Subset</h3><h3 id="Permutation">Permutation</h3><ul>
<li>这里通过boolean[] used, 来处理duplicate.</li>
<li>例子：[1 2 3 4 4 4 5 6 7 8]. 这个例子via <a href="http://www.cnblogs.com/yuzhangcmu/p/4141085.html" target="_blank" rel="external">CMUyu</a><ul>
<li>444这个的选法只能:4, 44, 444连续这三种选法. 即是说: 只对第一个4做递归调用. 然后对于后面2个4就不用递归了, 因为第一个4已经将这3种选法保存到result里面了.</li>
</ul>
</li>
<li>当然, Permutation在工作中的代码时尽量要避免的, 所以follow up很有可能是要求用iteration来解. 见Code ganker. 或者下面这个Next Permutation.</li>
</ul>
<h3 id="Combination">Combination</h3><ul>
<li>典型的模版套用</li>
</ul>
<h3 id="Combination_Sum">Combination Sum</h3><h3 id="Letter_Combination_of_a_Phone_number">Letter Combination of a Phone number</h3><h3 id="Palindrome_Partitioning">Palindrome Partitioning</h3><h3 id="Restore_IP_Address">Restore IP Address</h3><h3 id="8_queen">8 queen</h3><ul>
<li>如何选取valid subproblem.</li>
</ul>
<h3 id="Coin">Coin</h3>]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="NineChap" scheme="http://vlsi1217.github.io/tags/NineChap/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode中学习DP]]></title>
    <link href="http://vlsi1217.github.io/2015/02/21/Leetcode/LeetcodeDP/"/>
    <id>http://vlsi1217.github.io/2015/02/21/Leetcode/LeetcodeDP/</id>
    <published>2015-02-22T04:17:16.000Z</published>
    <updated>2015-05-14T01:46:09.767Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>这一篇想整理一下在LC中学到的DP. 一是学习如何推DP公式, 一是学如何优化.</li>
<li>另外2篇是: <ul>
<li>Leetcode中学习Recursion.</li>
<li>Leetcode中学习贪心</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="学习">学习</h1><h2 id="CLRS">CLRS</h2><ul>
<li>rod cut<h2 id="Stanford">Stanford</h2></li>
<li>WIS</li>
</ul>
<h2 id="ACM_资料">ACM 资料</h2><ul>
<li><a href="http://www.douban.com/note/213102442/" target="_blank" rel="external">DP的3个特性</a><ul>
<li>这个豆瓣文章不错, 讲了基本上面试会用的所有基本数据结构和算法.</li>
<li>其中是3个特性: <ol>
<li>最优子结构</li>
<li>无后效性</li>
<li>空间需求度</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="最简单的DP:_Unique_Path">最简单的DP: Unique Path</h1><h1 id="2D_DP经典:_distinct_subsequences">2D DP经典: distinct subsequences</h1><h1 id="2D_DP优化为1D_DP的经典:_Distinct_Subsequences/Coin_changes">2D DP优化为1D DP的经典: Distinct Subsequences/Coin changes</h1><h2 id="分析来自CSDN">分析来自<a href="http://blog.csdn.net/kenden23/article/details/19332545" target="_blank" rel="external">CSDN</a></h2><ul>
<li><h1 id="2D_DP经典:_LCS">2D DP经典: LCS</h1><h2 id="Naive_recursion">Naive recursion</h2><h2 id="2D_DP">2D DP</h2></li>
<li>DP打表有个关键: 先构造好表, 理解并初始化边界, 然后找规律填几行. <h2 id="1D_DP_(真1层)">1D DP (真1层)</h2></li>
<li>我昨天就是想当然的直接像coin change那样直接改成1D, 其实是不对的, 因为不是opt[i][j] ~ opt[i+1][j], 而是opt[i+1][j+1]. 因为我们的opt[i][j]的定义是x[i…M] vs y[j…N]. 所以必须从后往前/从下往上扫. 所以j+1在被j使用之前就改了. 因为这里打表是想使用修改前的值. 而且不能从反过来(前向后扫), 因为这里和<a href="">ganker distinct subsequence</a>不同???<h2 id="O(1)D的DP,_也就是1,2,3,_…_的常数层">O(1)D的DP, 也就是1,2,3, … 的常数层</h2></li>
<li>其实我使用的[0..1/2/3][0..N]这样一个<a href="http://sxyckjzh.blog.163.com/blog/static/32629815201361010642951/" target="_blank" rel="external"><strong>滚动数组</strong></a></li>
<li>如果是3层的滚动数组, 如POJ 1159 Palindrome的话, 可以用取mod来找到正确的行, 如<a href="http://www.cnblogs.com/PJQOOO/p/3900677.html" target="_blank" rel="external">ACM女神</a> 也就是常用的方法(见Valid sudoku). 如果是2层的滚动数组, 可以用我在LCS里面的双buffer. 或者可以直接使用2层的数组做(可以mod, 或者^1), 见<a href="http://www.ahathinking.com/archives/115.html#more-115" target="_blank" rel="external">dp[k][j] = dp[k^1][j-1] +  1</a></li>
<li>参考资料: <a href="http://blog.csdn.net/u011262722/article/details/10037855" target="_blank" rel="external">这个分了DP类: 斜率, 压缩</a></li>
<li><a href="http://blog.csdn.net/lp_opai/article/details/43408081" target="_blank" rel="external">ACM分类, KMP7题</a></li>
</ul>
<h2 id="LCS经典变形:_POJ_1159_Palindrome">LCS经典变形: POJ 1159 Palindrome</h2><ul>
<li>实际上LCS这里的subsequence是不连续的顺序子串. 所以可以利用这一点来解决Palindrome问题.</li>
<li>只要将给的String 反转, 比较LCS, 然后加入len-LCS即可.</li>
<li>如果要返回得到的Palindrome怎么弄?</li>
</ul>
<h2 id="2D_vs_1D">2D vs 1D</h2><ul>
<li>关键就在于可不可以recover. 例如</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Leetcode总结题型.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode freq 3]]></title>
    <link href="http://vlsi1217.github.io/2015/02/20/Leetcode/highFreq/Freq3/"/>
    <id>http://vlsi1217.github.io/2015/02/20/Leetcode/highFreq/Freq3/</id>
    <published>2015-02-21T04:17:16.000Z</published>
    <updated>2015-05-22T17:31:09.539Z</updated>
    <content type="html"><![CDATA[<h1 id="Leetcode_freq_3">Leetcode freq 3</h1><p>标签（空格分隔）： leetcode</p>
<hr>
<h1 id="Frequency_3题解">Frequency 3题解</h1><p>[TOC]</p>
<h2 id="20141218">20141218</h2><h3 id="Combination_-_N00t">Combination - N00t</h3><ul>
<li>标准的recursion DFS模版. 牢记于心.</li>
<li>而且有topdown和buttomup2个写法. 其中BU更简练.</li>
<li>还有iteration的写法.</li>
</ul>
<h3 id="Letter_Combinations_of_a_Phone_Number">Letter Combinations of a Phone Number</h3><ul>
<li>然后再来看这道题, 可以用Simple&amp;Stupid的做法, 和N00t的Combination差不多.</li>
<li>或者N00t的iteration解法.</li>
</ul>
<h3 id="Combination_Sum_I/II">Combination Sum I/II</h3><ul>
<li>N00t和Ganker结合. 注意2个的区别: I是可以reuse自己. 即可以用2(0), 2(0). 这里的2(0)表示在位置0的2. eg: {2, 2, 3, 7} 求sum=7. 而II是不能reuse自己. 所以答案是2(0), 2(1).</li>
</ul>
<h3 id="Maximum_Subarray_I/II">Maximum Subarray I/II</h3><ul>
<li>N00t的I是用的简单的一次过. 里面的sum初始化的条件是sum&lt;0. 但是看了Ganker的方法才知道原来这道题目是典型的DP.</li>
<li>其实LC的要求是不用DP做来达到O(n). 而是用Divide and Conquer来做. 看水中的鱼(C++). 或者一天一学(Java): <a href="http://joycelearning.blogspot.com/2013/10/leetcode-maximum-subarray.html" target="_blank" rel="external">链接</a></li>
<li>其实II并<strong>不能</strong>用N00t的做法. 因为有可能出现有多个subarray的值都一样! 可以看LintCode的解法: <a href="http://codeanytime.blogspot.com/2014/12/lintcode-maximum-subarray-ii.html" target="_blank" rel="external">链接</a></li>
</ul>
<h3 id="Jump_Game">Jump Game</h3><ul>
<li>Ganker在Maximum Subarray里面提到了DP里面常用的一个方法: 称为”局部最优和全局最优解法”. 在Jump game里面也用到了.</li>
</ul>
<h2 id="20141217">20141217</h2><h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><ul>
<li><a href="http://blog.csdn.net/linhuanmars/article/details/20888505" target="_blank" rel="external">Ganker CSDN大神的DP解法</a></li>
<li>当然还是N00t的解法作为入口开始理解.</li>
</ul>
<h3 id="Largest_Rectangle_in_Histogram">Largest Rectangle in Histogram</h3><ul>
<li>N00t: 双Stack, 一个stack</li>
<li>CSDN/abcbc: <a href="http://blog.csdn.net/abcbc/article/details/8943485" target="_blank" rel="external">双Stack</a></li>
<li>GeekForGeek: sliding window, segment tree. 这2个做法很重要!要认真理解.</li>
</ul>
<h3 id="Search_a_2D_Matrix">Search a 2D Matrix</h3><ul>
<li>简单题: 用2次binary search. 或者当作1个sorted array只要一次binary search就行了.</li>
</ul>
<h3 id="Partition_List">Partition List</h3><ul>
<li>参考的Ganker的答案, 但是有点混乱了. Java里面不是copy的handle吗? 那walk, runner一直改变, 不是也同时改变了helper吗?</li>
<li>ANS: NONONONONO. 双指针大法: walker/runner只是copy了pointer. 而每次walker = walker.next. 就assign了walker到下一个pointer. 这和C/C++一样.</li>
</ul>
<h3 id="Number_of_Islands">Number of Islands</h3><ul>
<li>简单题. ProgramCreek使用的recursion解法.</li>
</ul>
<h2 id="20141208">20141208</h2><h3 id="Populating_Next_Right_Pointers_in_Each_Node">Populating Next Right Pointers in Each Node</h3><h3 id="Divide_Two_Integers">Divide Two Integers</h3><h3 id="Search_in_Rotated_Sorted_Array_I/II">Search in Rotated Sorted Array I/II</h3><h3 id="Deep_Iterator_:_LinkedIn老题目">Deep Iterator : LinkedIn老题目</h3><ul>
<li>C++的解法: <a href="http://www.fgdsb.com/2015/01/19/nested-iterator/" target="_blank" rel="external">fgdsd的解法</a> 以及<a href="http://www.oodesign.com/iterator-pattern.html" target="_blank" rel="external">Iterator pattern</a></li>
<li><del>Rosetta算法大全里面也有解法</del> 这只是print Flatten, 不是iterator: <a href="http://rosettacode.org/wiki/Flatten_a_list#Java" target="_blank" rel="external">Java解法link</a></li>
<li>还是包子铺好, 有Java的解法(是iteration, 使用Stack来替代recursion, 上面讲recursion简单些): <a href="http://blog.baozitraining.org/2014/08/linkedin-twitter-and-hulu-onsite-how-to.html" target="_blank" rel="external">iteration解法</a></li>
<li>其实这是一个常见的模式: <strong>Iterator and Composite Pattern</strong>. 见Head First Design Pattern. 这是最好的解法. 设计+代码</li>
</ul>
<h2 id="20141206">20141206</h2><h3 id="Search_In_Sorted_Array">Search In Sorted Array</h3><ul>
<li>同类题目: Search Insert Position</li>
<li>同类题目: Search for a range</li>
</ul>
<h3 id="Multiply_Strings">Multiply Strings</h3><ul>
<li>初看之下, 就是一道简单题目啊, str2num然后乘起来不就行了? 其实不行, 因为会太大(??)</li>
<li>第一种解法初看之下也是平淡无奇, 但其实分析的时候发现居然把array和charAt的顺序搞混了. 45-&gt;num1 = [4,5]. 这里的num1[0] = 4! 所以45*123的res要做成5位, 并将第一位留为0. 因为最终可能进位.</li>
</ul>
<h3 id="N-Queens_I/II">N-Queens I/II</h3><ul>
<li>Matrix67/N00t用的是位运算解决问题.</li>
<li>Ganker用的是传统的<strong>循环递归</strong>解决这种NP问题.</li>
<li>又听了段公子的DP+Recursion讲座. 讲了用遍历+backtracking这种都是NP, 即是NP问题. 里面也提到了像Word Break这种可以Top-Down(memorize)和Button-Up(DP)的区别. 以及求CSP的个数和所有解空间的区别.</li>
<li>Quora上面讲了top-down跟button-up的DP都不一定需要用recursion.</li>
</ul>
<h2 id="20141205">20141205</h2><h3 id="Restore_IP_Addresses">Restore IP Addresses</h3><ul>
<li>太好了, 又深入的理解了recursion. 这里虽然只有一次显式的recursion, 但他是位于loop里面, 后面还有个results.add(). 以及共用(?和谁)一个results. 所以这种是一个今天学到的recursion: loop内的recursion用于循环遍历一层.</li>
<li>N00t果然是recursion很厉害. 佩服. 这里是DFS还是BFS? 是不是子解树? 之前看的那个CSDN 链接在哪?</li>
</ul>
<h3 id="Triangle_Path_Sum">Triangle Path Sum</h3><ul>
<li>很好的DP问题. 简单, 也分为top-down, 和button-up的2种思维方式.</li>
<li>初始化List<list<>&gt;费了些心思, 觉得还是anonymous inner class比较简洁. <a href="http://mangstacular.blogspot.com/2013/04/4-ways-to-initialize-list-in-java.html" target="_blank" rel="external">link</a>. 其中<a href="http://www.programmerinterview.com/index.php/java-questions/java-anonymous-class-example/" target="_blank" rel="external">programinterview的讲解很清晰</a></list<></li>
<li>N00t的top-down又让我深入理解了recursion中的param是primitive/object的区别. 以及call stack的new和clr的过程(Eclipse).</li>
<li>暂时还没看N00t的top-down的BFS解法………………………………….</li>
</ul>
<h3 id="Surrounded_Regions">Surrounded Regions</h3><ul>
<li>极度经典的图形学算法题目: flood fill. 同时关于DFS/BFS的取舍. 以及Queue的API: offer/poll. (这和stack的push/pull对应)</li>
<li>参考Ganker/N00t的解法.</li>
<li>Palindrome Partitioning I/II</li>
<li><p>N00t大神的DP+DP/DP+, 还有美丽的<strong>partitionHelper()</strong></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> <span class="type">void</span> recur(<span class="type">String</span> s, <span class="type">int</span> left, <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt; <span class="literal">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == s.length()) &#123;</span><br><span class="line">      <span class="literal">result</span>.add(new <span class="type">ArrayList</span>&lt;<span class="type">String</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt; temp = new <span class="type">ArrayList</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;();</span><br><span class="line">      recur(s, i + <span class="number">1</span>, temp);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">List</span>&lt;<span class="type">String</span>&gt; partitions : temp) &#123;</span><br><span class="line">        partitions.add(<span class="number">0</span>, s.substring(left, i + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="literal">result</span>.addAll(temp);  // add()和addAll()的区别.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>想到了word segment, word spell out, Matrix Chain multiplication</p>
<ul>
<li>也是一道经典recursion题目. 而且还看到了在for each里面的recursion call. 怎么展开呢? 太美了的recursion!</li>
<li><a href="http://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/" target="_blank" rel="external">word spell out 链接</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/" target="_blank" rel="external">Matrix Chain Multiplication链接</a></li>
<li><a href="http://stackoverflow.com/questions/5275002/recursively-spell-out-a-word" target="_blank" rel="external">Word Split: SOF链接</a></li>
<li>20150423: subsequence+matching的题目首先想到的应该是DP: 见<a href="http://jane4532.blogspot.com/2013/11/palindrome-partitioning-iileetcode.html" target="_blank" rel="external">sophieJ的解法</a></li>
</ul>
</li>
</ul>
<h3 id="Word_Segment_I/II">Word Segment I/II</h3><ul>
<li>Naive做法是N00t的好</li>
<li>DP做法有2D和1D, 可以是aray或者arrayList, N00t的做法和ProgramCreek的不同.</li>
<li>Word Break II的主要参照programCreek的做法. 很完美经典的DFS+DP解法. 漂亮!!! ProgramCreek还赔了图, 其中的words即dp[].显而可见index为什么是s.length()+1了. <img src="http://www.programcreek.com/wp-content/uploads/2014/03/word-break-II-java-298x400.png" alt="ProgramCreek的配图"></li>
</ul>
<h2 id="20141129">20141129</h2><h3 id="Find_the_k-th_Smallest_Element_in_the_Union_of_Two_Sorted_Arrays">Find the k-th Smallest Element in the Union of Two Sorted Arrays</h3><ul>
<li>先理解这道题再做median of two array.</li>
<li>这里关键的问题可以转化为: 找B[j-1] &lt;A[i] &lt; B[j] 或者 A[i-1] &lt; B[j] &lt; A[i]. 如果不成立就recursion. 注意这里因为Java不能用指针, 所以要稍微站换一下1337的写法.</li>
</ul>
<h3 id="Median_of_Two_Sorted_Arrays">Median of Two Sorted Arrays</h3><ul>
<li>这题有很多思考, 值得说道说道. 这题是源自于CLRS. 而且里面还简化了: m=n. 而LC这道题是generic的.</li>
<li>要做这题先要理解这道题: Find the k-th Smallest Element in the Union of Two Sorted Arrays. 见上.<br>+</li>
</ul>
<h3 id="Regular_Expression_Matching">Regular Expression Matching</h3><ul>
<li>如何保证考虑详细?</li>
<li>N00t的解法很好<ul>
<li>不知道怎样才能像他那样那么有逻辑. 不会有错漏. 这个if/else设计的太美了</li>
<li>redundant分析我觉得不对. 因为到了2nd iteration中. “b” vs “a<em>a</em>b”是不会有3个substructure的. 因为不match.</li>
<li>backtracking做法中, 一个用substring, 一个就是用2个指针i,j. 避免了substring()来copy浪费空间. 不过之所以这里可以用”char array”是因为这里只是比对. 而不需要修改. 所以直接reference即可. 但是像之前的partitionHelper里面可以用吗??? 或者是更之前的:</li>
</ul>
</li>
</ul>
<h3 id="Wildcard_Matching">Wildcard Matching</h3><pre><code><span class="addition">+</span>
</code></pre><h2 id="20141118">20141118</h2><h3 id="Construct_Binary_Tree_from_Inorder_and_Postorder_traversal">Construct Binary Tree from Inorder and Postorder traversal</h3><ul>
<li>首先通过pre, post, in加深了对recursion的理解.</li>
<li>还是老话, 思考问题的方式. 先是找规律. 发现pre order的头的root, 然后可以在In order里面找到左右子树的大小, 再回到pre order里面找到左右子树的root. 如此recursion.</li>
</ul>
<h3 id="construct_binary_tree_from_preorder_and_inorder_traversal">construct binary tree from preorder and inorder traversal</h3><ul>
<li>举一反三. 找规律看到了post-order反着读的话就正好是pre order的mirror. 所以这次从post order的尾巴开始读. 发现尾巴就是root, 然后回到inorder里面找左右子树的大小. 从而回到post-order里面找左右子树的root. 要注意的是不能点到mid &lt; end和mid &gt; start! 一开始就这样, 发现有错误, 进行到一半就停了.</li>
<li>Flatten Binary Tree to Linked List</li>
<li><a href="http://n00tc0d3r.blogspot.com/2013/03/flatten-binary-tree-to-linked-list-in.html" target="_blank" rel="external">太好了, 终于完全理解复杂recursion了</a></li>
</ul>
<h3 id="Path_Sum">Path Sum</h3><ul>
<li>root-to-leaf Path sum: <a href="http://www.programcreek.com/2013/01/leetcode-path-sum/" target="_blank" rel="external">ProgramCreek的解法</a></li>
<li>Binary Tree Maximum Path Sum</li>
<li>Find ALL Path Sum</li>
</ul>
<h3 id="Reverse_Integer">Reverse Integer</h3><ul>
<li>要注意overflow, 跟负号</li>
</ul>
<h3 id="Unique_Paths_I/II">Unique Paths I/II</h3><ul>
<li>经典的DP问题</li>
<li>也是path问题, 可以找规律, 变成排列组合题.</li>
<li>如果有obstacle呢?</li>
<li>觉得还是N00t的解法比较好. 相对于1337的2D opt, 这个只要1D. 而且可以解出来.</li>
</ul>
<h3 id="Longest_Consecutive_Sequence">Longest Consecutive Sequence</h3><ul>
<li>还是觉得N00t的方法. 还是一样, 学会抽象, 不要以为tree型就一定要用tree实现, 或者range就必须要知道左右和长度. 要有了整体把握才设计API. HashMap的关键在于key/value的设计.</li>
<li>还是N00t的”simple”(不觉得simple, 然而很多技巧在里面). 好聪明的做法. 果然是精通API和recursion的N00t.</li>
</ul>
<h2 id="20141115">20141115</h2><h3 id="Edit_Distance">Edit Distance</h3><ul>
<li>这个是个经典的DP问题.  是Stanford Algs 2 DP问题DNA Sequence Alignment的扩展, 因为不只是ACGT, 也不只是Gap, 而是有3种操作. 注意n00tc0d3r的DP的优化! (用的空间是O(min(l1, l2) 而不是通常的O(l1*l2)) 我觉得这个是一个通用的optimize方法. 是不是four Russian(不是)?</li>
</ul>
<h3 id="One_Edit_Distance">One Edit Distance</h3><ul>
<li>这个看起来就是直接用Edit Distance就行了. 其实会超时间! 注意是one distance. 所以直接1 pass.</li>
</ul>
<h3 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h3><ul>
<li>很喜欢N00tc03的post-order=pre-order的mirror.</li>
</ul>
<h3 id="Binary_Tree_ZigZag_level_order_Traversal">Binary Tree ZigZag level order Traversal</h3><ul>
<li>这个属于BFS. 注意看题意: 输出是要按照parent来加上括号. 而不是只要按照顺序就行的. 所以有2中方法:</li>
<li>法1: 用flag</li>
<li>法2: SRAM的双buffer. 这里使我真正的理解了<strong>github_addtion.bellmanFord()</strong>! 原来reachableNode, 和nextreachableNodes就和queue, queueBuffer的关系一样. 都是用来<strong>update到下一个layer</strong>的.</li>
<li>注意要用2个loop, out-loop创建reslist来保存currLevel的值, 创建childLevel来保存下一层. in-loop用来填充res和childLevel</li>
</ul>
<h2 id="20141112">20141112</h2><h3 id="Convert_Sorted_list_to_BST_(in-order,_Button-up)">Convert Sorted list to BST (in-order, Button-up)</h3><ul>
<li>这个和array的区别是array可以O(1) search, LinkedList要O(n). 所以不行. 但是想到BST是in-order. 可以直接从leaf开始. 也就是<strong>Buttom-up recursive</strong>. 但是要注意的是recursion的写法. 真正理解: 位于recursive call之前和之后的code的意义是什么. 这在Algs4的BST讲过. 在Stanford的SCC的DFS_loop讲过.</li>
</ul>
<h3 id="Convert_Sorted_Array_to_BST">Convert Sorted Array to BST</h3><ul>
<li>简单. 因为BST是按顺序的, 所以recursive拿middle并左右路.</li>
</ul>
<h3 id="Remove_duplicates_from_sorted_Array">Remove duplicates from sorted Array</h3><ul>
<li>这个可以看N00tc0d3r的解法. 先学会remove element from array</li>
<li>而且用Nth-to-end里面的双指针, 距离n+1个node!</li>
</ul>
<h3 id="Median_of_Two_Sorted_Arrays-1">Median of Two Sorted Arrays</h3><ul>
<li>比较难. 而且大部分答案都不对. 还是得看1337c0d3r的答案分析. 正统. 他让先看: Find the k-th Smallest Element in the Union of Two Sorted Arrays. 他说这个是这道题的基础.</li>
</ul>
<h3 id="Remove_duplicates_from_sorted_List">Remove duplicates from sorted List</h3><ul>
<li>关键在于list的删除要给出这个node的前一个node, 然后用pre.next = pre.next.next.</li>
</ul>
<hr>
<h2 id="题目">题目</h2><table>
<thead>
<tr>
<th>#</th>
<th>Leetcode problem</th>
<th>freq</th>
</tr>
</thead>
<tbody>
<tr>
<td>26</td>
<td><del>Remove Duplicates from Sorted Array</del></td>
<td>3</td>
</tr>
<tr>
<td>83</td>
<td><del>Remove Duplicates from Sorted List</del></td>
<td>3</td>
</tr>
<tr>
<td>112</td>
<td><del>Path Sum</del></td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td><del>Reverse Integer</del></td>
<td>3</td>
</tr>
<tr>
<td>19</td>
<td><del>Remove Nth Node From End of List</del></td>
<td>3</td>
</tr>
<tr>
<td>62</td>
<td><del>Unique Paths</del></td>
<td>3</td>
</tr>
<tr>
<td>108</td>
<td><del>Convert Sorted Array to Binary Search Tree</del></td>
<td>3</td>
</tr>
<tr>
<td>17</td>
<td><del>Letter Combinations of a Phone Number</del></td>
<td>3</td>
</tr>
<tr>
<td>39</td>
<td><del>Combination Sum</del></td>
<td>3</td>
</tr>
<tr>
<td>53</td>
<td><del>Maximum Subarray</del></td>
<td>3</td>
</tr>
<tr>
<td>63</td>
<td><del>Unique Paths II</del></td>
<td>3</td>
</tr>
<tr>
<td>64</td>
<td><del>Minimum Path Sum</del></td>
<td>3</td>
</tr>
<tr>
<td>74</td>
<td><del>Search a 2D Matrix</del></td>
<td>3</td>
</tr>
<tr>
<td>82</td>
<td><del>Remove Duplicates from Sorted List II</del></td>
<td>3</td>
</tr>
<tr>
<td>86</td>
<td><del>Partition List</del></td>
<td>3</td>
</tr>
<tr>
<td>93</td>
<td><del>Restore IP Addresses</del></td>
<td>3</td>
</tr>
<tr>
<td>105</td>
<td><del>Construct Binary Tree from Preorder and Inorder</del></td>
<td>3</td>
</tr>
<tr>
<td>106</td>
<td><del>Construct Binary Tree from Inorder and Postorder</del></td>
<td>3</td>
</tr>
<tr>
<td>114</td>
<td><del>Flatten Binary Tree to Linked List</del></td>
<td>3</td>
</tr>
<tr>
<td>116</td>
<td>~~Populating Next Right Pointers in Each Node</td>
<td>3</td>
</tr>
<tr>
<td>29</td>
<td>~~Divide Two Integers</td>
<td>3</td>
</tr>
<tr>
<td>33</td>
<td>~~Search in Rotated Sorted Array</td>
<td>3</td>
</tr>
<tr>
<td>34</td>
<td><del>Search for a Range</del></td>
<td>3</td>
</tr>
<tr>
<td>43</td>
<td><del>Multiply Strings</del></td>
<td>3</td>
</tr>
<tr>
<td>51</td>
<td><del>N-Queens</del></td>
<td>3</td>
</tr>
<tr>
<td>52</td>
<td><del>N-Queens II</del></td>
<td>3</td>
</tr>
<tr>
<td>72</td>
<td><del>Edit Distance</del></td>
<td>3</td>
</tr>
<tr>
<td>94</td>
<td><del>Binary Tree Inorder Traversal</del></td>
<td>3</td>
</tr>
<tr>
<td>103</td>
<td><del>Binary Tree Zigzag Level Order Traversal</del></td>
<td>3</td>
</tr>
<tr>
<td>109</td>
<td><del>Convert Sorted List to Binary Search Tree</del></td>
<td>3</td>
</tr>
<tr>
<td>128</td>
<td><del>Longest Consecutive Sequence</del></td>
<td>3</td>
</tr>
<tr>
<td>130</td>
<td><del>Surrounded Regions</del></td>
<td>3</td>
</tr>
<tr>
<td>132</td>
<td><del>Palindrome Partitioning II</del></td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td><del>Median of Two Sorted Arrays</del></td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td><del>Regular Expression Matching</del></td>
<td>3</td>
</tr>
<tr>
<td>44</td>
<td><del>Wildcard Matching</del></td>
<td>3</td>
</tr>
<tr>
<td>81</td>
<td><del>Search in Rotated Sorted Array II</del></td>
<td>3</td>
</tr>
<tr>
<td>end</td>
<td>念念不忘必有回响</td>
<td>3</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode 系统设计题目]]></title>
    <link href="http://vlsi1217.github.io/2015/02/16/Leetcode/System/"/>
    <id>http://vlsi1217.github.io/2015/02/16/Leetcode/System/</id>
    <published>2015-02-17T04:17:16.000Z</published>
    <updated>2015-05-11T21:30:36.228Z</updated>
    <content type="html"><![CDATA[<h2 id="20150306">20150306</h2><h3 id="Short_URL">Short URL</h3><ul>
<li>参考N00t的设计</li>
</ul>
<h3 id="Battlefield">Battlefield</h3><h3 id="Game_of_Life">Game of Life</h3><ul>
<li>参考Holub书中的介绍以及UML</li>
</ul>
<h3 id="Chess">Chess</h3><ul>
<li>参考Github的UML</li>
</ul>
<h3 id="Collaberative_Editor_(Google_doc)">Collaberative Editor (Google doc)</h3><ul>
<li>参考isnowfy的设计<a href="http://www.isnowfy.com/collaborative-editor/" target="_blank" rel="external">Blog链接</a><br><img src="/images/Leetcode/google_doc.png" alt="google_doc"></li>
</ul>
<h3 id="Google_自动补全搜索">Google 自动补全搜索</h3><p>* </p>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="Interview" scheme="http://vlsi1217.github.io/categories/Interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode freq 2]]></title>
    <link href="http://vlsi1217.github.io/2015/02/16/Leetcode/highFreq/Freq2/"/>
    <id>http://vlsi1217.github.io/2015/02/16/Leetcode/highFreq/Freq2/</id>
    <published>2015-02-17T04:17:16.000Z</published>
    <updated>2015-05-22T17:31:13.062Z</updated>
    <content type="html"><![CDATA[<h2 id="20141228">20141228</h2><h3 id="Populating_Next_Right_Pointers_in_Each_Node_II">Populating Next Right Pointers in Each Node II</h3><p>*</p>
<h3 id="Lowest_Common_Ancestors_I/II:">Lowest Common Ancestors I/II:</h3><h4 id="I:_即没有parent的pointer怎么做?">I: 即没有parent的pointer怎么做?</h4><ul>
<li>这题不仅在九章算法课第二课里面讲了, 而且在<a href="http://articles.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html" target="_blank" rel="external">1337文章link</a>也详细的解释了Bottom-up的意义. 我认为那个是设计思路.</li>
<li><p>先复习一下: top-down/bottom-up approach: <a href="http://www.meetqun.com/thread-2732-1-1.html" target="_blank" rel="external">TD/BU的区别-米群讨论</a>, 但是里面大牛的回答也不准确, DP的top-down/bottom-up和recursion没什么关系. 例如这里的LCA的Bottom-up就是recursion. 但是Scramble String的3D Bottom-up DP就是iteration. 那么在Bottom-up有什么好处呢? 在Binary Tree的BU解法中, 相对于Top-Down是</p>
<blockquote>
<p>avoiding traversing the same nodes over and over again.      —- 1337</p>
</blockquote>
<ul>
<li>就<strong>树</strong>来说: 最准确的解释就是: <a href="https://xiangcaohello.wordpress.com/2014/06/22/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86%E6%A0%91%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97/" target="_blank" rel="external">自底向上=post order traversal</a>, 以及这篇<a href="http://www.cnblogs.com/airwindow/p/4285203.html" target="_blank" rel="external">Bottom-up解题报告</a></li>
<li>其次<a href="http://wp.javayu.me/2014/02/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external">javayu的解释</a>: 树的bottom-up方式和top-down方式的主要差别就在于：先处理当前节点还是先处理子树</li>
</ul>
</li>
</ul>
<ul>
<li>而且这里很有意思的是Top down的LCA是recursion, 里面还调用countMatches这个小recursion.<ul>
<li>这还是见得比较少的, 一般就是client调用helper recursion.</li>
<li>照<a href="http://www.faceye.net/search/136311.html" target="_blank" rel="external">Tree总结</a>所总结的万金油方法, 不过这个表述没看明白, 原来是在<a href="http://www.cnblogs.com/leetcode/p/4003795.html" target="_blank" rel="external">cnblog symetric Tree</a>里面的分析的思路:<blockquote>
<ol>
<li>top-down 还是 bottom-up.    选择top-down.        O(n^2)</li>
<li>用递归. 是否需要内嵌小递归.   需要. 其实就是判定root的是否一样的小递归.</li>
<li>逻辑运用小递归.</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="这道题的follow_up:_parent_pointer">这道题的follow up: parent pointer</h4><ul>
<li>如果每个node有parent pointer的话呢? 可以怎么改进: <a href="http://articles.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-ii.html" target="_blank" rel="external">LCA II</a></li>
<li>在九章算法的第二课就讲了, 90% Tree的题目可以用Divide &amp; Conquer做. 注意D&amp;C和Traverse的recursion区别在于前者有return value. 因为在<strong>治</strong>的阶段需要对<strong>分</strong>的结果进行合并处理.</li>
</ul>
<h3 id="Minimum_Adjustment_Cost:_Lintcode动态规划题目">Minimum Adjustment Cost: Lintcode动态规划题目</h3><ul>
<li>参考的是<a href="http://www.cnblogs.com/yuzhangcmu/p/4153927.html" target="_blank" rel="external">主页君的cnblog和github</a>分析的很详细, 有4种解法:<blockquote>
<p>其实就是NP问题的backtracking解法. 但还是老问题, 怎么找到解集合?</p>
</blockquote>
</li>
</ul>
<p><img src="http://7xj2zx.com1.z0.glb.clouddn.com/9chap_minAdjCost.png" alt="九章算法黄老师课上的课件"></p>
<h3 id="Binary_Tree_Maximum_Path_Sum">Binary Tree Maximum Path Sum</h3><ul>
<li>这题是diameter/height的扩展题. 因为题目还包含了不经过root的情况. 其实都是dfs recursion. 只是要同时保存single path和sum. 即<ul>
<li>single path是经过当前node的一边的max: Math.max(l.path, r.path)+root.v -&gt; 经过当前node的边的最大值. 0-&gt;即经过此node的边为负.</li>
<li>sum则是左右sum的最大值, 或者左右边最大值加上当前node.</li>
</ul>
</li>
<li><p>由<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-binary-tree-maximum-path-sum.html" target="_blank" rel="external">嘻唰唰blog</a>题解里面分析的: 对于每一个node的Maximum Path Sum分2类:</p>
<blockquote>
<ol>
<li>single path是指由该node出发向leaf的第一类path中最大的path sum</li>
<li>以x为LCA的第二类path中的最大path sum</li>
</ol>
</blockquote>
</li>
<li><p>正是因为看到嘻唰唰提到的LCA, 所以去看了1337的LCA文章, 受益良多. 加深对top-down/bottom-up的理解.</p>
</li>
</ul>
<h3 id="Diameter_and_Height_of_Binary_Tree">Diameter and Height of Binary Tree</h3><ul>
<li>做Binary Tree Maximum Path Sum之前先做一下类似理解的题目: Diameter of Binary Tree: <a href="http://n00tc0d3r.blogspot.com/2013/07/diameter-of-binary-tree.html" target="_blank" rel="external">N00t帖子</a><blockquote>
<p>树没有被看成有向图，而是被当成无向图来寻找路径 — <a href="http://blog.csdn.net/linhuanmars/article/details/22969069" target="_blank" rel="external">Ganker</a></p>
</blockquote>
</li>
<li>标准的DFS. 注意base case一定要return来终止.</li>
<li>注意Height必须是进过root, 但是Diameter并不一定. 参见N00t的配图. 而N00t的公式则按照(SOF解释](<a href="http://stackoverflow.com/a/11897490" target="_blank" rel="external">http://stackoverflow.com/a/11897490</a>). 很好理解了.</li>
</ul>
<h3 id="Next_Permutation">Next Permutation</h3><ul>
<li>先理解什么意思: 见<a href="http://www.nayuki.io/page/next-lexicographical-permutation-algorithm" target="_blank" rel="external">Nayuyi.io的解释</a>. 正如水中鱼所说: 这道题目就是一个观察题, 以及基本的array操作. 比如交换, index, loop的break. 复杂度只能是O(3*n)</li>
<li>我还是参考的水中的鱼的思路. 找到partitionNum, partitionIdx, changeNum. 然后交换partionNum, changeNum. 接着再reverse num.substring(partitionIdx+1).</li>
<li>Ganker和水中的鱼对于changeNum的找法有一点微小区别.</li>
</ul>
<h3 id="First_Missing_Positive">First Missing Positive</h3><ol>
<li><p>其实这就是bucket sorting. 是最快的排序法, 比qsort还快. 是O(n), 但是是用空间换时间.</p>
<p>可以generalize为更实用的radix sort.</p>
<blockquote>
<p>A type of bucket sort called the counting sort —- <a href="https://www-927.ibm.com/ibm/cas/hspc/student/algorithms/BucketSort.html" target="_blank" rel="external">IBM link</a></p>
</blockquote>
</li>
</ol>
<ul>
<li>bucket sort, radix sort, bubble sort, counting sort —- <a href="https://courses.cs.washington.edu/courses/cse373/13wi/lectures.shtml#today" target="_blank" rel="external">University of Washington CSE 373</a><ul>
<li>注意这里的最后一步就是Concatenation bucket到原array的时候有3个var, 不要搞混了.</li>
</ul>
</li>
<li>注意ganker的内循环判定的条件是<code>A[i] != A[A[i]-1]</code>. 而且最后要<code>i--</code>. 为什么不能换成<code>A[i] != i+1</code>.<ul>
<li>因为若是换成直接判断A[i]!=i+1的话, 则会导致在重复字符的情况下出现死循环.</li>
<li>之所以i—. 是因为交换完之后不一定是正确的. 例如{3,1,2}一开始的3,2交换为2,3后, 2并不是正确位置. 所以再判断2,1并交换才对.</li>
<li>所以Ganker说这道题目很简单, 但其中包含的算法思想和编程基础很适合面试!</li>
</ul>
</li>
</ul>
<h3 id="Largest_Rectangle_in_Histogram">Largest Rectangle in Histogram</h3><h3 id="Scramble_String:_3D_动态规划经典">Scramble String: 3D 动态规划经典</h3><ul>
<li>Google考过, 见<a href="http://www.mitbbs.com/article_t/JobHunting/32107851.html" target="_blank" rel="external">MITBBS 2012年帖子</a></li>
<li>先理解这个Scramble是什么意思: <code>s1 = &quot;great&quot;, s2 = &quot;rtgae&quot;;</code>就不是有效的. 注意要求是</li>
<li>这道题目可以用recursion, 更可以用DP. 是一道经典的3D DP. 但正如段公子所说: DP table可以用array也可以用HashMap, 可见武大csdn的hashmap解法. 但是觉得这个和N00t的backtracking差不多? 看看九章算法主页君的就搞懂了, 其实不一样.</li>
<li><p>参考的:</p>
<ul>
<li><a href="http://blog.csdn.net/fightforyourdream/article/details/17707187" target="_blank" rel="external">fightforyourdream的recursion+DP</a>.</li>
<li><a href="http://blog.csdn.net/whuwangyi/article/details/14105063" target="_blank" rel="external">武大CSDN的Hashmap动态规划</a>,</li>
<li><a href="http://blog.unieagle.net/2012/10/23/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Ascramble-string%EF%BC%8C%E4%B8%89%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="external">Unieagele解题博客的3D动归</a></li>
<li><p><a href="http://www.cnblogs.com/yuzhangcmu/p/4189152.html" target="_blank" rel="external">九章算法主页君—CMUyu</a></p>
<ul>
<li>分析的答案很适合面试的顺序: recursion-&gt;剪枝-&gt;Top-down DP(memorize)-&gt;Bottom-up DP(iteration).</li>
<li>而且时间空间复杂度分析的很详细.</li>
</ul>
</li>
<li><p>Ganker的3D动归, 和N00t的意思差不多. 不过Ganker的分析不错.</p>
<ul>
<li><p>难点在于for loop的顺序. 最外层应该是len. 因为是bottom-up. 从小问题推大问题. 或者说大问题的解可以使用小问题的解得到, 而不用反复求解同一个小问题.</p>
<blockquote>
<p>对于判断这些左右部分是不是scramble我们是有历史信息的，因为长度小于n的所有情况我们都在前面求解过了（也就是长度是最外层循环）。</p>
</blockquote>
</li>
<li><p>有点没搞明白: 为什么Ganker说:</p>
<blockquote>
<p>如果以上两种情况有一种成立，说明s1[i…i+len-1]和s2[j…j+len-1]是scramble的。</p>
</blockquote>
</li>
</ul>
</li>
<li>水中的鱼的recursion, 他的剪枝很好, 可以AC. 而N00t的原始的recursion(即brute-force的剪枝仅仅比较s1,s2的长度, 是很低效率的, 所以过不了).</li>
<li>N00t的递归, DP (bottom-up) 就是iteration, 而LCA的DP (bottom-up)则是recursion. 那么这个是怎么想出来的呢:<blockquote>
<ul>
<li>先理解递归是怎么做的: 从大到小substr判断. 即切割成substructure/subproblem.</li>
<li>For each pair of (n-1)-char-long substrings of the two strings, are they scramble to each other?</li>
<li>For each pair of (n-2)-char-long substrings, are they scramble?</li>
<li>… …</li>
<li>For each pair of 2-char-long substrings, are they scramble?</li>
<li>For each pair of char in the two strings, are they scramble (i.e. do they equal)?</li>
<li>That is saying, we can build up a table and solve the problem in a bottom-up fashion.</li>
<li>然后还有就是这里的递推式一开始没有理解. 看了<code>fight for your dream</code>懂了: 还是recursion的想法,2种情况: 前前&amp;&amp;后后||前后&amp;&amp;后前. **注意: 这种var(i,j,k,p)变多了之后不要搞混了. 最好的方法就是写一个例子出来.</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Interleaving_String:_2D/1D_动态规划">Interleaving String: 2D/1D 动态规划</h3><blockquote>
<p>凡是substring的题目, 都是自动脑补动态规划, 正如Tree的题目自动脑补分治法.</p>
</blockquote>
<h4 id="方法1:_recursion">方法1: recursion</h4><ul>
<li>当然, 最好先从简单的做法入手, 先有个做对的方法: recursion是DP的前提. 或者说有了递归的思路就好想出来DP了.<ul>
<li>对于在recursion call里面处理下一个substring的话, 即修改index, 有2种方法.<ol>
<li>例如remove duplicate from string, 因为简单的赋值. 所以res[j++] = s[i++];</li>
<li>在N00t的recursive call里面, 因为一句话里面有2个地方用到i,k. eg: <code>s1[i] == s3[k] &amp;&amp; isInterleave(s1, s2, s3, i+1, j, k+1)</code>. 我一开始是用++i, j++. 这样很容易弄混. 直接干脆用<code>i+1</code>.</li>
<li>总结一下: 如果是简单的method call, 可以使用<code>++i; j++</code>. 不过长一点的statement还是不要弄晕自己, 代码最好不要依赖于statement的顺序, 所以还是原始的<code>i+1</code>.</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="http://7xj2zx.com1.z0.glb.clouddn.com/freq2_interleave.jpg" alt="2D打表图示"></p>
<h4 id="方法2:_2D_递归">方法2: 2D 递归</h4><ul>
<li>既然recursion已经想出来了, 也就弄明白了? (not yet! 想法出来还要写代码实现, 里面很多门道和细节的设计)</li>
<li>首先是边界条件, 或者说base case的设计: 有个trick, 每次遇到string的DP, 都要增加一个空位. 表示s1, s2都不取的情况. 所以Opt[0][0] = true. 这里参考的<a href="http://blog.csdn.net/u011095253/article/details/9248073" target="_blank" rel="external">popfish的算法路blog画的2D 打表图示</a>. 我一开始做的时候, 在打1st row和1st col的时候直接就是比较substring了. 但是结果不对. 为什么呢: 因为substring没用对.<ul>
<li>有2点关于substring要注意<ol>
<li>substring上界是开区间. 所以<code>substring(0,0)</code>是<code>&quot;&quot;</code>, (0,1)才相当于<code>charAt(0)</code>.</li>
<li>刚发现: <code>&quot;n&quot;==&quot;n&quot;</code>是true, 但是<code>&quot;ni&quot;.substring(0,1)==&quot;no&quot;.substring(0,1)</code>居然是<strong>false</strong>! 刚查了<a href="http://stackoverflow.com/a/513839" target="_blank" rel="external">SOF: how to compare string</a>, 以及<a href="http://stackoverflow.com/questions/3297867/difference-between-string-object-and-string-literal" target="_blank" rel="external">SOF: string object vs string literal</a>, 才知道:<blockquote>
<p><del><strong>Java的<code>==</code>比较<em>string</em>的时候比较的是reference, 而不是value!</strong>.</del> 应该说: Java 的 “==”比较object的时候, 是看是否为同一个reference.<br>所以2个substring的reference不同, 当然就是false!</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="方法3:_1D_递归-_参考Ganker的解法-">方法3: 1D 递归. 参考Ganker的解法.</h4><ul>
<li>注意到2D的递推式只和上一层和左边的有关: <code>opt[i][j] ~ {opt[i-1][j], opt[i][j-1]}</code>. 所以可以只用一个1D 的 dp表就可以了. 当然这个时候就要小心了. 有几点:<ol>
<li>长度多少? 意义已经改变了.<ul>
<li>对于处理2个string的问题, 有个trick: 一般都最好选择短的那个处理, 可以节省空间或者时间.当然<code>opt[minWord.length()+1]</code>, 而且因为是需要update 短的opt长度. 所以将opt update放在内层短循环可以更加优化. 因为opt[0]<del>的意义</del>, 有2个含义:<ul>
<li>一个意义是到外层循环到i的时候, opt[0]表示第一列的第i个时候, 表示原本2d中的opt[0][j]. 即看s3[0…j]是否可以用MaxWord[0…j], 而没有MinWord. 来interleave.</li>
<li>第二个意义是: 内层循环到j的时候, s3[0…i+j+1]是否可以由maxWord[0…i]minWord[0…j]来interleave.</li>
</ul>
</li>
</ul>
</li>
<li>因为外层循环maxWord, 内层循环minWord. 所以1st row可以单独初始化. 而1st col, 即maxWord的interleave的base caseze’y则要在外层循环中初始化. 而将minWord放在内层循环upodate可以节省DP表空间.</li>
<li>最关键的在于递推式现在怎么样勒?<ul>
<li>我一开始就搞错了. 一定要注意: 1D其实就是2D压缩而来的. 所以就是2D的简化版. 所以要和2D的递推式紧密联合起来想.</li>
<li>2D的递推式: <code>opt[i+1][j+1] = opt[i][j+1] &amp;&amp; s1[i] 或者 opt[i+1][j] &amp;&amp; s2[j]</code>. 所以<code>opt[j+1]</code>和上一层或者左边有关: <code>opt[j+1] = opt[j+1] &amp;&amp; maxWord[i] 或者 opt[j] &amp;&amp; minWord[j]</code>. 关键在于搞清楚现在上一层和左边需要的char是哪一个. 注意这里的j是横轴啊!<ul>
<li>所以2d里面的左边, 即opt[i][j+1]则相当于1d里面的(opt[j])就是由2d里面的s1(横着的string).</li>
<li>而j+1, 就是相当于2D里面的上一层, 即相当于opt[i+1][j]. 所以是和2d里面的s2(竖着的string), 所以是maxWord的char.</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="20141226">20141226</h2><h3 id="Reverse_Nodes_in_k-Group">Reverse Nodes in k-Group</h3><ul>
<li>先做Swap Nodes in Pairs. 注意Ganker提到的, list常用的技巧就是遇到需要修改root的题目一般都是接一个空的node到root, 这样就把root退化为一般的中间node.</li>
<li>这题主要参考<a href="http://n00tc0d3r.blogspot.com/2013/05/reverse-linked-list.html" target="_blank" rel="external">N00t的解法</a>. 即Invariant是2个node, keep track这2个node. 头脑要清晰. 在写之前想好算法.</li>
<li>N00t里面这个reverse list的时候的思路超级清晰. 想想为什么是这样写. <strong>关键</strong>在于<blockquote>
<p>pre, cur是不变的[以N00t的例子为例, 到结束的时候, 实际上pre还是指向1, cur还是指向2], 只改变pre.next, cur.next. 以及这2个next之间的link.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定位好之后就可以开始交换了. 这里是这个<span class="function"><span class="keyword">method</span>的关键.</span></span><br><span class="line"><span class="keyword">while</span> (pos &lt; <span class="keyword">end</span> &amp;&amp; cur != <span class="literal">null</span>) &#123;</span><br><span class="line">  ListNode tmp = cur.<span class="keyword">next</span>.<span class="keyword">next</span>; // N00t用的是nt: node temp.</span><br><span class="line">  cur.<span class="keyword">next</span>.<span class="keyword">next</span> = pre.<span class="keyword">next</span>; // cur;</span><br><span class="line">  pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">  cur.<span class="keyword">next</span> = tmp; // pre.<span class="keyword">next</span>.<span class="keyword">next</span> = tmp;</span><br><span class="line">  pos++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><h3 id="Permutations_I/II">Permutations I/II</h3><ul>
<li>NP问题的做法基本都是用Backtracking. 想象这里和Combination有什么区别呢?<ul>
<li>Ans: 这里子问题的条件变化了. Combination里面是helper(,i+1,). 这里是每次在loop里面使能used[i] = true, helper(used[i]). 这样就能缩小到下一个子问题.</li>
<li>这很重要. 因为recursion就是要一步步进入子问题, 解决, 跳出递归, 到保存到stack的以前的现场. 所以ganker也强调了这里要在helper()后面恢复现场, 即list.remove(list.size()-1), 以及初始化used[i]. 即used[i] = false.</li>
</ul>
</li>
<li>II就是加入了一个条件: 如果是{1,2,1} 呢? 要避免112, 112出现2次的情况, 就要在dfs之前先判断是否和上一个num重复(**因为num已经sort过了).</li>
<li><a href="http://blog.csdn.net/linhuanmars/article/details/21569031" target="_blank" rel="external">评论的一个follow up: link</a>. 其实很简单, 也是加入一个判断是否和上一个item里面最后一个数相等, 若是就continue.</li>
</ul>
<h3 id="Rotate_Image">Rotate Image</h3><h3 id="Text_Justification">Text Justification</h3><ul>
<li>考察基本功的好题目, 注意题目的各个细节. 参考的ganker的解.<ol>
<li>什么是last呢? 即本行的开头, 什么是i呢?下行的开头. 什么是i-last-1呢? 就是该行的间隔个数. 例如该行如果可以放5个单词, 开头的last是4, 下一行开头是9. 那么9-1就是该行的结尾, 9-1-4既是该行有4个间隔.</li>
<li>为什么下一步循环的时候判断<code>if(j&lt;i-1)</code>呢? 这很好理解, 因为分配<code>\b</code>只跟间隔有关, end的词在一行只有一个词的时候才要pad空格.</li>
<li>上面2这个if语句里面最后的extraNum—是什么意思呢? 注意题目要求是尽量平均分配. 所以多余的就从start开始的间隔每个+1. 注意这里的extraNum是%间隔数. 所以最多的情况是每一个间隔的空格都加1个. 否则就是靠左的间隔s分到一个extra的空格.<blockquote>
<p>“Extra spaces between words should be distributed as evenly as possible.”</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="Sort_Colors">Sort Colors</h3><ul>
<li>其实就是counting sort. 拓展题就是如何压缩, 如何返回最长连续char及其个数.</li>
<li>follow up: 如何使用O(1)的空间来做? 而且O(n)的time? N00t和Ganker都是用的双指针. 好聪明, 怎么想到的?<ul>
<li>最主要还是和reverse Nodes k-group的思想一样, 想好invarient. 可以这样想. 如果sort的colors只有0,1. 那么就只要一个pointer0, 然后i一个一个往下走, 如果遇到了0, 就赋值, pionter0++. 相当于swap的操作.</li>
<li>现在可以看看有3个colors: 0,1,2的话怎么用pointers呢? ans: 就用2个pointers: p0, p1. 遇到0就赋值, p0++, p1++. 遇到1就赋值, p1++. 为什么这个时候p0不改变呢? 因为??????</li>
</ul>
</li>
</ul>
<h3 id="Minimum_Window_Substring">Minimum Window Substring</h3><ul>
<li>先去复习longest non-repeated substring和Concatenation (freq1), 因为方法都一样:<blockquote>
<p>建立一个字典，然后维护一个窗口</p>
</blockquote>
</li>
<li>都是substring match 字典. 这一点类似的还有Word break(Ganker的DP解)</li>
<li>看了N00t的Concatenation里面讲了原来双指针窗口法<del>原来就是KMP</del>(并不是KMP).不过KMP, BM, KR都很重要.<br>-</li>
</ul>
<h3 id="Gray_Code">Gray Code</h3><ul>
<li>使用的方法就是ASIC里面介绍的方法. 有意思. 感觉KMP也是FSM.</li>
<li>原来Gray code就是汉诺塔的解… N00t的一行解法太cool, 没看明白啥意思.</li>
</ul>
<h3 id="Subsets_I/II">Subsets I/II</h3><ul>
<li>还是Permutation/Combination这种NP问题的解法: backtracking. 只是有一点点区别: 在处理加入的元素时要去掉一些不符合条件的.</li>
<li>很好的题目, 再次加深理解Recursion, 不仅仅是像我在<a href="https://www.zybuluo.com/mdeditor#80599" target="_blank" rel="external">LC中学习Recursion</a>那样还停留在Recursion代码之前, 之后的代码的意义. 而是要深入理解Recursion思维的想法和设计.<ul>
<li>recursion里面, subset加入的顺序是怎么样的? 如何保证 non-descending order? Ans: 其实就是对自己设计的recursion要理解, 只到recursion的顺序就ok了. 因为Ganker的rec是从3,2,1,0,-1 递减的call. 而N00t则是0,1,2,4递增的call. 所以顺序不同. 具体的trace可以参考P533-Algs4-DFS.</li>
<li>还有就是为什么N00t的输出是从[3], [2]开始, 而Ganker的则是从[1], [1,2]开始. 这是因为base case 的判断的区别, 以及recur进入下一层子问题的顺序是递增还是递减. 这很有意思. 要thinking in recursion.</li>
</ul>
</li>
</ul>
<h2 id="20141225">20141225</h2><h3 id="Path_Sum_I/II">Path Sum I/II</h3><ul>
<li>树的题目很常见, 但是方法都类似: recursion.</li>
<li>问题也很常见: I一般就是问是否存在解. II一般是求所有解的集合.</li>
<li>正是这道题目, N00t讲了Java的call by value对于object来说是copy他的handler, 即reference, 所以将来的改变会对之前add的reference改变, 也就改变了最终的结果:<blockquote>
<ul>
<li>Notice that we make a copy of the path before we added it to our result set. The reason is that when we add an Object (here, an ArrayList), Java add a copy of the pointer (i.e. a reference) of the Object, rather than a deep copy. So, <strong>any changes to content</strong> of the original Object will reflect into our final result set.</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>同样的Ganker也是<code>res.add(new ArrayList&lt;Integer&gt;(item));</code>. 否则必然是错误的.</li>
<li>为什么N00t的if (root.value==sum)里面放path到res之后不能return, 否则会出现错误的path? 因为这个里面加上return是完全错误的! 这里并不是base case, 不应该return. 但是Ganker的为什么又应该加上return呢? 因为这个是base case. 注意Ganker的顺序.</li>
</ul>
<h3 id="Longest_Substring_Without_Repeating_Characters">Longest Substring Without Repeating Characters</h3><ul>
<li>N00t的方法是hashmap+start/end2个pointer的移动, 注意N00t只要判断当前的char是不是在当前substring中, 才update. 考虑到返回所有这种substring的问题. 我的思路是记录longest的start, 这样因为maxlength是返回值. 所以substring就可以解决. 但是有点小问题.</li>
<li>Ganker则是使用的walker/runner 双指针法. 或者说: 窗口法来处理这一类的string问题. 还归了类. 一开始没理解为什么是while(charAt(w)!=charAt(r)). 想到了一个好例子: “xyb12b02”. 走了一遍理解了. 本来给的例子: “abcabcbb”并不好. 因为W=R都是连续的, 没看到while不等的情况. 所以有时候要多举几个case. 但不是随便举. 而是想上面那个case那样第一个重复的’b’并不是第一个字母.<ul>
<li>扩展的题目有Substring with Concatenation of All Words，Minimum Window Substring，思路是非常接近的，只是操作上会更加繁琐一些。</li>
</ul>
</li>
<li>case很重要, 一是在开始做题之前用来理解, 考虑算法之用. 二来是作为test case. 但是case也要设计得好才行, 不然还是会错. 所以要建立在完全理解题意, 想好算法之后写<strong>有用</strong>的case, 来改正算法. 有点鸡生蛋, 但实际上是要懂了再下笔. 面试不是调代码.</li>
</ul>
<h3 id="Longest_Consecutive_int_string">Longest Consecutive int string</h3><ul>
<li>这道题在GoPro onsite面到. 其实很简单的recursion. 题目意思是给一个排好序的string: “abccdeeeeef”, 则’e’是重复次数最多, 有5次. 所以返回: e和5. 其实这个和compression很相同, 之前见过: 将这个string输出为”a1b1c2d1e5f1”</li>
<li>思路参考的<a href="">SOF上面的recursion</a>.</li>
</ul>
<h3 id="Container_With_Most_Water">Container With Most Water</h3><h3 id="Jump_Game">Jump Game</h3><ul>
<li>经典的DP和Greedy问题. 段公子在DP/recursion里面讲了.</li>
<li>第二题的想法在N00t和Ganker之间有区别. 可以加深理解. 也确实想了好久才明白他们的code.</li>
<li>Ganker的评论里面又一个记录path的方法, 这样可以返回最少jump的path. 总而言之, 也是一个DP的方法. DP还是Greedy? 傻傻分不清. 还要回头<strong>复习一下贪新算法</strong>: MST.</li>
</ul>
<h3 id="3Sum/4Sum">3Sum/4Sum</h3><ul>
<li>主要参考N00t和Ganker的解法. 但其实可以结合HashSet来做4Sum. 更简单.</li>
<li>注意这里面的设计, 如何避免重复. 所以要sort. 通常的解法是夹逼法则. for loop循环3-2或者4-2个头, 然后剩下2个index可以用left/right来夹逼.</li>
<li>注意这里正确的使用了do…while.</li>
<li>Binary search的合理使用. 一般不会直接写一个binary search. 但是这里夹逼自然是binary search好用. O(n)-&gt;O(lgn)</li>
</ul>
<h3 id="Spiral_Matrix_I/II">Spiral Matrix I/II</h3><ul>
<li>N00t的这张图真是经典, 也确实是复杂题目想好psuedo code才写!</li>
<li>Hello WOrld</li>
</ul>
<h3 id="Recover_Binary_Search_Tree">Recover Binary Search Tree</h3><ul>
<li><p>再次加深了对Recursion的理解. 2个不连续的recursion. 而且param还不对称, N00t的recursion写的真好. N00t的方法也很好.</p>
<h3 id="Distinct_Subsequences">Distinct Subsequences</h3><blockquote>
<p>+When you see string problem that is about subsequence or matching, dynamic programming method should come to your mind naturally. —-by <a href="http://www.cnblogs.com/springfor/p/3896152.html" target="_blank" rel="external">link</a></p>
</blockquote>
<ul>
<li>DP的经典题目. N00t的做法也是可以的. 但我倾向于Ganker/SophieJ. 但是要理解DP公式的含义. 不然连边界条件或者初始条件都搞不出来. Ganker的2D分析, 然后code则是优化为1D dp的解法一开始没看懂, 然后Ganker在回复里面解释了为什么j是从T的<strong>从后向前扫</strong>. 这是因为这里的<strong>DP是想使用update之前的值</strong>, 所以这样. 如果以后有个DP问题是要使用更新后的1D dp, 则是从头往后扫.</li>
<li>还是的加深理解为什么1D的逆向填的DP是对的? 会不会导致比较出来的subsequence没按顺序? 或者反过来了? 见<a href="http://blog.csdn.net/kenden23/article/details/19332545" target="_blank" rel="external">csdn link</a> 有点乱: 下标, 如何保证是in-order? 看Coin Change—-段公子.</li>
</ul>
</li>
</ul>
<h2 id="20141223">20141223</h2><h3 id="Plus_One">Plus One</h3><ul>
<li>这是一道简单题. N00t给出了他的扩展题: plus int.</li>
<li>Ganker说他在Google店面的时候就问了这题. 因为适合扩展和OOD的设计.<h3 id="Symmetric_Tree">Symmetric Tree</h3></li>
<li>Ganker是简单的recursion和iteration. 注意这里判断是否对称的条件: 空的情况, 有值的情况. 注意不用判断值相等. 为什么? 因为helper是recursion, 要找到结束得点. 而值相等可以继续走下去. 而都为空就可以直接返回true. 因为走不下去了. 这里也明显的看出iteration为什么会繁琐.</li>
<li>N00t使用的一种stl数据结构: ArrayDeque. 其他思路和Ganker是一样的.</li>
</ul>
<h3 id="Balanced_Binary_Tree">Balanced Binary Tree</h3><h3 id="Palindrome_Number">Palindrome Number</h3><ul>
<li>和Freq3的PalindromeDPDP类似.</li>
<li>这里的比较2end不能用pointer了. 因为不是string. 这里有2个方法. 用一个div(不断变化). 本质还是loop里面update为指向对称的end points.</li>
<li>或者是1337里面的第三个方法: 用一个stack.</li>
</ul>
<h3 id="Search_Insert_Position">Search Insert Position</h3><ul>
<li>在freq3里面已经做过</li>
</ul>
<h3 id="Valid_Sudoku">Valid Sudoku</h3><ul>
<li>巧妙使用<code>i/3*3</code>和<code>i%3*3</code>. 以及API的设计</li>
</ul>
<h3 id="SOlve_Sudoku">SOlve Sudoku</h3><ul>
<li>加深理解循环递归. 觉得比NP的N-Queens更重要. 这里的设计是很重要的模版.</li>
</ul>
<h3 id="Count_and_Say">Count and Say</h3><ul>
<li>String的小题目. 一定要bug free.</li>
<li>题目居然没看懂. 还是看了<a href="http://blog.csdn.net/fightforyourdream/article/details/12901505" target="_blank" rel="external">CSDN上面FightForDream的帖子</a>才搞明白什么意思.<h3 id="Remove_Duplicates_from_Sorted_Array_I/II">Remove Duplicates from Sorted Array I/II</h3></li>
<li>好在我回顾了这道题目. 发现N00t的思路太不好了, 很容易错, 而且扩展不了. 实际上有string, 有比较的时候就用pointer就好了. 而且这里还是in-place. 就算是II, 也只要多加一个变量cnt来看当前有几次重复元素.</li>
<li>所以Ganker的方法远胜于N00t. 也保证了这种简单题目的清晰思路和bug-free. 就是通过</li>
</ul>
<hr>
<h2 id="题目">题目</h2><table>
<thead>
<tr>
<th>#</th>
<th>Leetcode problem</th>
<th>freq</th>
</tr>
</thead>
<tbody>
<tr>
<td>66</td>
<td>~Plus One</td>
<td>2</td>
</tr>
<tr>
<td>101</td>
<td>~Symmetric Tree</td>
<td>2</td>
</tr>
<tr>
<td>110</td>
<td>~Balanced Binary Tree</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>~Palindrome Number</td>
<td>2</td>
</tr>
<tr>
<td>35</td>
<td>~Search Insert Position</td>
<td>2</td>
</tr>
<tr>
<td>36</td>
<td>~Valid Sudoku</td>
<td>2</td>
</tr>
<tr>
<td>38</td>
<td>~Count and Say</td>
<td>2</td>
</tr>
<tr>
<td>80</td>
<td>~Remove Duplicates from Sorted Array II</td>
<td>2</td>
</tr>
<tr>
<td>113</td>
<td>~Path Sum II</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>~Longest Substring Without Repeating Characters</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>~Container With Most Water</td>
<td>2</td>
</tr>
<tr>
<td>18</td>
<td>~4Sum</td>
<td>2</td>
</tr>
<tr>
<td>55</td>
<td>~Jump Game</td>
<td>2</td>
</tr>
<tr>
<td>59</td>
<td>~Spiral Matrix II</td>
<td>2</td>
</tr>
<tr>
<td>61</td>
<td>~Rotate List</td>
<td>2</td>
</tr>
<tr>
<td>92</td>
<td>~Reverse Linked List II</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>~Longest Palindromic Substring</td>
<td>2</td>
</tr>
<tr>
<td>25</td>
<td>Reverse Nodes in k-Group</td>
<td>2</td>
</tr>
<tr>
<td>37</td>
<td>Sudoku Solver</td>
<td>2</td>
</tr>
<tr>
<td>40</td>
<td>Combination Sum II</td>
<td>2</td>
</tr>
<tr>
<td>42</td>
<td>Trapping Rain Water</td>
<td>2</td>
</tr>
<tr>
<td>45</td>
<td>Jump Game II</td>
<td>2</td>
</tr>
<tr>
<td>47</td>
<td>Permutations II</td>
<td>2</td>
</tr>
<tr>
<td>48</td>
<td>Rotate Image</td>
<td>2</td>
</tr>
<tr>
<td>54</td>
<td>Spiral Matrix</td>
<td>2</td>
</tr>
<tr>
<td>68</td>
<td>Text Justification</td>
<td>2</td>
</tr>
<tr>
<td>75</td>
<td>Sort Colors</td>
<td>2</td>
</tr>
<tr>
<td>76</td>
<td>Minimum Window Substring</td>
<td>2</td>
</tr>
<tr>
<td>89</td>
<td>Gray Code</td>
<td>2</td>
</tr>
<tr>
<td>90</td>
<td>Subsets II</td>
<td>2</td>
</tr>
<tr>
<td>99</td>
<td>Recover Binary Search Tree</td>
<td>2</td>
</tr>
<tr>
<td>115</td>
<td>Distinct Subsequences</td>
<td>2</td>
</tr>
<tr>
<td>117</td>
<td>Populating Next Right Pointers in Each Node II</td>
<td>2</td>
</tr>
<tr>
<td>124</td>
<td>Binary Tree Maximum Path Sum</td>
<td>2</td>
</tr>
<tr>
<td>31</td>
<td>Next Permutation</td>
<td>2</td>
</tr>
<tr>
<td>41</td>
<td>First Missing Positive</td>
<td>2</td>
</tr>
<tr>
<td>84</td>
<td>Largest Rectangle in Histogram</td>
<td>2</td>
</tr>
<tr>
<td>87</td>
<td>Scramble String</td>
<td>2</td>
</tr>
<tr>
<td>97</td>
<td>Interleaving String</td>
<td>2</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[A collection of Hello World applications from helloworld.org.]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://vlsi1217.github.io/categories/Leetcode/"/>
    
  </entry>
  
</feed>